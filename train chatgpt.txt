'shit', 'fuck', 'bitch', 'ass', 'pussy', 'dick', 'cock', 'cunt', 'nigger', 'cracker', 'fag'

Creating the main file
TIP

This page assumes you've already prepared the configuration files from the previous page. We're using the config.json approach, however feel free to substitute your own!

Open your code editor and create a new file. We suggest that you save the file as index.js, but you may name it whatever you wish.

Here's the base code to get you started:

// Require the necessary discord.js classes
const { Client, Events, GatewayIntentBits } = require('discord.js');
const { token } = require('./config.json');

// Create a new client instance
const client = new Client({ intents: [GatewayIntentBits.Guilds] });

// When the client is ready, run this code (only once)
// We use 'c' for the event parameter to keep it separate from the already defined 'client'
client.once(Events.ClientReady, c => {
	console.log(`Ready! Logged in as ${c.user.tag}`);
});

// Log in to Discord with your client's token
client.login(token);
This is how you create a client instance for your Discord bot and log in to Discord. The GatewayIntentBits.Guilds intents option is necessary for the discord.js client to work as you expect it to, as it ensures that the caches for guilds, channels, and roles are populated and available for internal use.

TIP

The term "guild" is used by the Discord API and in discord.js to refer to a Discord server.

Intents also define which events Discord should send to your bot, and you may wish to enable more than just the minimum. You can read more about the other intents on the Intents topic.

#Running your application
Open your terminal and run node index.js to start the process. If you see "Ready!" after a few seconds, you're good to go! The next step is to start adding slash commands to develop your bot's functionality.

TIP

You can open your package.json file and edit the "main": "index.js" field to point to your main file. You can then run node . in your terminal to start the process!

After closing the process with Ctrl + C, you can press the up arrow on your keyboard to bring up the latest commands you've run. Pressing up and then enter after closing the process is a quick way to start it up again.






















Creating slash commands

User
used /ping

Guide Bot
BOT
07/29/2023
Pong!
Discord allows developers to register slash commands, which provide users a first-class way of interacting directly with your application.

Slash commands provide a huge number of benefits over manual message parsing, including:

Integration with the Discord client interface.
Automatic command detection and parsing of the associated options/arguments.
Typed argument inputs for command options, e.g. "String", "User", or "Role".
Validated or dynamic choices for command options.
In-channel private responses (ephemeral messages).
Pop-up form-style inputs for capturing additional information.
...and many more!

#Before you continue
Assuming you've followed the guide so far, your project directory should look something like this:

discord-bot/
├── node_modules
├── config.json
├── index.js
├── package-lock.json
└── package.json
TIP

For fully functional slash commands, there are three important pieces of code that need to be written. They are:

The individual command files, containing their definitions and functionality.
The command handler, which dynamically reads the files and executes the commands.
The command deployment script, to register your slash commands with Discord so they appear in the interface.
These steps can be done in any order, but all are required before the commands are fully functional.

On this page, you'll complete Step 1. Make sure to also complete the other pages linked above!

#Individual command files
Create a new folder named commands, which is where you'll store all of your command files. You'll be using the SlashCommandBuilder class to construct the command definitions.

At a minimum, the definition of a slash command must have a name and a description. Slash command names must be between 1-32 characters and contain no capital letters, spaces, or symbols other than - and _. Using the builder, a simple ping command definition would look like this:

new SlashCommandBuilder()
	.setName('ping')
	.setDescription('Replies with Pong!');
A slash command also requires a function to run when the command is used, to respond to the interaction. Using an interaction response method confirms to Discord that your bot successfully received the interaction, and has responded to the user. Discord enforces this to ensure that all slash commands provide a good user experience (UX). Failing to respond will cause Discord to show that the command failed, even if your bot is performing other actions as a result.

The simplest way to acknowledge and respond to an interaction is the interaction.reply() method. Other methods of replying are covered on the Response methods page later in this section.

async execute(interaction) {
	await interaction.reply('Pong!')
}
Put these two together by creating a commands/ping.js file for your first command. Inside this file, you're going to define and export two items.

The data property, which will provide the command definition shown above for registering to Discord.
The execute method, which will contain the functionality to run from our event handler when the command is used.
These are placed inside module.exports so they can be read by other files; namely the command loader and command deployment scripts mentioned earlier.

commands/ping.js
const { SlashCommandBuilder } = require('discord.js');

module.exports = {
	data: new SlashCommandBuilder()
		.setName('ping')
		.setDescription('Replies with Pong!'),
	async execute(interaction) {
		await interaction.reply('Pong!');
	},
};
TIP

module.exports is how you export data in Node.js so that you can require() it in other files.

If you need to access your client instance from inside a command file, you can access it via interaction.client. If you need to access external files, packages, etc., you should require() them at the top of the file.

That's it for your basic ping command. Below are examples of two more commands we're going to build upon throughout the guide, so create two more files for these before you continue reading.

commands/user.js
commands/server.js
const { SlashCommandBuilder } = require('discord.js');

module.exports = {
	data: new SlashCommandBuilder()
		.setName('user')
		.setDescription('Provides information about the user.'),
	async execute(interaction) {
		// interaction.user is the object representing the User who ran the command
		// interaction.member is the GuildMember object, which represents the user in the specific guild
		await interaction.reply(`This command was run by ${interaction.user.username}, who joined on ${interaction.member.joinedAt}.`);
	},
};



























Command handling
Unless your bot project is small, it's not a very good idea to have a single file with a giant if/else if chain for commands. If you want to implement features into your bot and make your development process a lot less painful, you'll want to implement a command handler. Let's get started on that!

TIP

For fully functional slash commands, there are three important pieces of code that need to be written. They are:

The individual command files, containing their definitions and functionality.
The command handler, which dynamically reads the files and executes the commands.
The command deployment script, to register your slash commands with Discord so they appear in the interface.
These steps can be done in any order, but all are required before the commands are fully functional.

This page details how to complete Step 2. Make sure to also complete the other pages linked above!

#Loading command files
Now that your command files have been created, your bot needs to load these files on startup.

In your index.js file, make these additions to the base template:

const fs = require('node:fs');
const path = require('node:path');
const { Client, Collection, Events, GatewayIntentBits } = require('discord.js');
const { token } = require('./config.json');

const client = new Client({ intents: [GatewayIntentBits.Guilds] });

client.commands = new Collection();
We recommend attaching a .commands property to your client instance so that you can access your commands in other files. The rest of the examples in this guide will follow this convention. For TypeScript users, we recommend extending the base Client class to add this property, casting, or augmenting the module type.

TIP

The fs module is Node's native file system module. fs is used to read the commands directory and identify our command files.
The path module is Node's native path utility module. path helps construct paths to access files and directories. One of the advantages of the path module is that it automatically detects the operating system and uses the appropriate joiners.
The Collection class extends JavaScript's native Map class, and includes more extensive, useful functionality. Collection is used to store and efficiently retrieve commands for execution.
Next, using the modules imported above, dynamically retrieve your command files with a few more additions to the index.js file:

client.commands = new Collection();

const commandsPath = path.join(__dirname, 'commands');
const commandFiles = fs.readdirSync(commandsPath).filter(file => file.endsWith('.js'));

for (const file of commandFiles) {
	const filePath = path.join(commandsPath, file);
	const command = require(filePath);
	// Set a new item in the Collection with the key as the command name and the value as the exported module
	if ('data' in command && 'execute' in command) {
		client.commands.set(command.data.name, command);
	} else {
		console.log(`[WARNING] The command at ${filePath} is missing a required "data" or "execute" property.`);
	}
}
First, path.join() helps to construct a path to the commands directory. The fs.readdirSync() method then reads the path to the directory and returns an array of all the file names it contains, currently ['ping.js', 'server.js', 'user.js']. To ensure only command files get processed, Array.filter() removes any non-JavaScript files from the array.

With the correct files identified, the last step is to loop over the array and dynamically set each command into the client.commands Collection. For each file being loaded, check that it has at least the data and execute properties. This helps to prevent errors resulting from loading empty, unfinished or otherwise incorrect command files while you're still developing.

#Receiving command interactions
Every slash command is an interaction, so to respond to a command, you need to create a listener for the Client#event:interactionCreate event that will execute code when your application receives an interaction. Place the code below in the index.js file you created earlier.

client.on(Events.InteractionCreate, interaction => {
	console.log(interaction);
});
Not every interaction is a slash command (e.g. MessageComponent interactions). Make sure to only handle slash commands in this function by making use of the BaseInteraction#isChatInputCommand() method to exit the handler if another type is encountered. This method also provides typeguarding for TypeScript users, narrowing the type from BaseInteraction to ChatInputCommandInteraction.

client.on(Events.InteractionCreate, interaction => {
	if (!interaction.isChatInputCommand()) return;
	console.log(interaction);
});
#Executing commands
When your bot receives a Client#event:interactionCreate event, the interaction object contains all the information you need to dynamically retrieve and execute your commands!

Let's take a look at the ping command again. Note the execute() function that will reply to the interaction with "Pong!".

module.exports = {
	data: new SlashCommandBuilder()
		.setName('ping')
		.setDescription('Replies with Pong!'),
	async execute(interaction) {
		await interaction.reply('Pong!');
	},
};
First, you need to get the matching command from the client.commands Collection based on the interaction.commandName. Your Client instance is always available via interaction.client. If no matching command is found, log an error to the console and ignore the event.

With the right command identified, all that's left to do is call the command's .execute() method and pass in the interaction variable as its argument. In case something goes wrong, catch and log any error to the console.

client.on(Events.InteractionCreate, async interaction => {
	if (!interaction.isChatInputCommand()) return;

	const command = interaction.client.commands.get(interaction.commandName);

	if (!command) {
		console.error(`No command matching ${interaction.commandName} was found.`);
		return;
	}

	try {
		await command.execute(interaction);
	} catch (error) {
		console.error(error);
		if (interaction.replied || interaction.deferred) {
			await interaction.followUp({ content: 'There was an error while executing this command!', ephemeral: true });
		} else {
			await interaction.reply({ content: 'There was an error while executing this command!', ephemeral: true });
		}
	}
});
#Command categories
So far, all of your command files are in a single commands folder. This is fine at first, but as your project grows, the number of files in the commands folder will too. Keeping track of that many files can be a little tough. To make this a little easier, you can categorize your commands and put them in subfolders inside the commands folder. You will have to make a few changes to your existing code in index.js for this to work out.

If you've been following along, your project structure should look something like this:

Project structure before sorting

After moving your commands into subfolders, it will look something like this:

Project structure after sorting

WARNING

Make sure you put every command file you have inside one of the new subfolders. Leaving a command file directly under the commands folder will create problems.

It is not necessary to name your subfolders exactly like we have named them here. You can create any number of subfolders and name them whatever you want. Although, it is a good practice to name them according to the type of commands stored inside them.

Back in your index.js file, where the code to dynamically read command files is, use the same pattern to read the subfolder directories, and then require each command inside them.

client.commands = new Collection();
const foldersPath = path.join(__dirname, 'commands');
const commandFolders = fs.readdirSync(foldersPath);

for (const folder of commandFolders) {
	const commandsPath = path.join(foldersPath, folder);
	const commandFiles = fs.readdirSync(commandsPath).filter(file => file.endsWith('.js'));
	for (const file of commandFiles) {
		const filePath = path.join(commandsPath, file);
		const command = require(filePath);
		// Set a new item in the Collection with the key as the command name and the value as the exported module
		if ('data' in command && 'execute' in command) {
			client.commands.set(command.data.name, command);
		} else {
			console.log(`[WARNING] The command at ${filePath} is missing a required "data" or "execute" property.`);
		}
	}
}
That's it! When creating new files for commands, make sure you create them inside one of the subfolders (or a new one) in the commands folder.

#Next steps
Your command files are now loaded into your bot, and the event listener is prepared and ready to respond. In the next section, we cover the final step - a command deployment script you'll need to register your commands so they appear in the Discord client





































Registering slash commands
TIP

For fully functional slash commands, you need three important pieces of code:

The individual command files, containing their definitions and functionality.
The command handler, which dynamically reads the files and executes the commands.
The command deployment script, to register your slash commands with Discord so they appear in the interface.
These steps can be done in any order, but all are required before the commands are fully functional.

This page details how to complete Step 3. Make sure to also complete the other pages linked above!

#Command registration
Slash commands can be registered in two ways; in one specific guild, or for every guild the bot is in. We're going to look at single-guild registration first, as this is a good way to develop and test your commands before a global deployment.

Your application will need the applications.commands scope authorized in a guild for any of its slash commands to appear, and to be able to register them in a specific guild without error.

Slash commands only need to be registered once, and updated when the definition (description, options etc) is changed. As there is a daily limit on command creations, it's not necessary nor desirable to connect a whole client to the gateway or do this on every ready event. As such, a standalone script using the lighter REST manager is preferred.

This script is intended to be run separately, only when you need to make changes to your slash command definitions - you're free to modify parts such as the execute function as much as you like without redeployment.

#Guild commands
Create a deploy-commands.js file in your project directory. This file will be used to register and update the slash commands for your bot application.

Add two more properties to your config.json file, which we'll need in the deployment script:

clientId: Your application's client id (Discord Developer Portal > "General Information" > application id)
guildId: Your development server's id (Enable developer mode > Right-click the server title > "Copy ID")
{
	"token": "your-token-goes-here",
	"clientId": "your-application-id-goes-here",
	"guildId": "your-server-id-goes-here"
}
With these defined, you can use the deployment script below:

const { REST, Routes } = require('discord.js');
const { clientId, guildId, token } = require('./config.json');
const fs = require('node:fs');
const path = require('node:path');

const commands = [];
// Grab all the command files from the commands directory you created earlier
const foldersPath = path.join(__dirname, 'commands');
const commandFolders = fs.readdirSync(foldersPath);

for (const folder of commandFolders) {
	// Grab all the command files from the commands directory you created earlier
	const commandsPath = path.join(foldersPath, folder);
	const commandFiles = fs.readdirSync(commandsPath).filter(file => file.endsWith('.js'));
	// Grab the SlashCommandBuilder#toJSON() output of each command's data for deployment
	for (const file of commandFiles) {
		const filePath = path.join(commandsPath, file);
		const command = require(filePath);
		if ('data' in command && 'execute' in command) {
			commands.push(command.data.toJSON());
		} else {
			console.log(`[WARNING] The command at ${filePath} is missing a required "data" or "execute" property.`);
		}
	}
}

// Construct and prepare an instance of the REST module
const rest = new REST().setToken(token);

// and deploy your commands!
(async () => {
	try {
		console.log(`Started refreshing ${commands.length} application (/) commands.`);

		// The put method is used to fully refresh all commands in the guild with the current set
		const data = await rest.put(
			Routes.applicationGuildCommands(clientId, guildId),
			{ body: commands },
		);

		console.log(`Successfully reloaded ${data.length} application (/) commands.`);
	} catch (error) {
		// And of course, make sure you catch and log any errors!
		console.error(error);
	}
})();
Once you fill in these values, run node deploy-commands.js in your project directory to register your commands to the guild specified. If you see the success message, check for the commands in the server by typing /! If all goes well, you should be able to run them and see your bot's response in Discord!


User
used /ping

Guide Bot
BOT
07/29/2023
Pong!
#Global commands
Global application commands will be available in all the guilds your application has the applications.commands scope authorized in, and in direct messages by default.

To deploy global commands, you can use the same script from the guild commands section and simply adjust the route in the script to .applicationCommands(clientId)

await rest.put(
	Routes.applicationCommands(clientId),
	{ body: commands },
);
#Where to deploy
TIP

Guild-based deployment of commands is best suited for development and testing in your own personal server. Once you're satisfied that it's ready, deploy the command globally to publish it to all guilds that your bot is in.

You may wish to have a separate application and token in the Discord Dev Portal for your dev application, to avoid duplication between your guild-based commands and the global deployment


































Event handling
Node.js uses an event-driven architecture, making it possible to execute code when a specific event occurs. The discord.js library takes full advantage of this. You can visit the Client documentation to see the full list of events.

TIP

This page assumes you've followed the guide up to this point, and created your index.js and individual slash commands according to those pages.

At this point, your index.js file has listeners for two events: ClientReady and InteractionCreate.

ClientReady
InteractionCreate
client.once(Events.ClientReady, c => {
	console.log(`Ready! Logged in as ${c.user.tag}`);
});
Currently, the event listeners are in the index.js file. Client#event:ready emits once when the Client becomes ready for use, and Client#event:interactionCreate emits whenever an interaction is received. Moving the event listener code into individual files is simple, and we'll be taking a similar approach to the command handler.

WARNING

You're only going to move these two events from index.js. The code for loading command files will stay here!

#Individual event files
Your project directory should look something like this:

discord-bot/
├── commands/
├── node_modules/
├── config.json
├── deploy-commands.js
├── index.js
├── package-lock.json
└── package.json
Create an events folder in the same directory. You can then move the code from your event listeners in index.js to separate files: events/ready.js and events/interactionCreate.js.

events/ready.js
events/interactionCreate.js
index.js (after)
const { Events } = require('discord.js');

module.exports = {
	name: Events.ClientReady,
	once: true,
	execute(client) {
		console.log(`Ready! Logged in as ${client.user.tag}`);
	},
};
The name property states which event this file is for, and the once property holds a boolean value that specifies if the event should run only once. You don't need to specify this in interactionCreate.js as the default behavior will be to run on every event instance. The execute function holds your event logic, which will be called by the event handler whenever the event emits.

#Reading event files
Next, let's write the code for dynamically retrieving all the event files in the events folder. We'll be taking a similar approach to our command handler. Place the new code highlighted below in your index.js.

fs.readdirSync().filter() returns an array of all the file names in the given directory and filters for only .js files, i.e. ['ready.js', 'interactionCreate.js'].

const fs = require('node:fs');
const path = require('node:path');
const { Client, Collection, GatewayIntentBits } = require('discord.js');
const { token } = require('./config.json');

const client = new Client({ intents: [GatewayIntentBits.Guilds] });

client.commands = new Collection();
const foldersPath = path.join(__dirname, 'commands');
const commandFolders = fs.readdirSync(foldersPath);

for (const folder of commandFolders) {
	const commandsPath = path.join(foldersPath, folder);
	const commandFiles = fs.readdirSync(commandsPath).filter(file => file.endsWith('.js'));
	for (const file of commandFiles) {
		const filePath = path.join(commandsPath, file);
		const command = require(filePath);
		if ('data' in command && 'execute' in command) {
			client.commands.set(command.data.name, command);
		} else {
			console.log(`[WARNING] The command at ${filePath} is missing a required "data" or "execute" property.`);
		}
	}
}

const eventsPath = path.join(__dirname, 'events');
const eventFiles = fs.readdirSync(eventsPath).filter(file => file.endsWith('.js'));

for (const file of eventFiles) {
	const filePath = path.join(eventsPath, file);
	const event = require(filePath);
	if (event.once) {
		client.once(event.name, (...args) => event.execute(...args));
	} else {
		client.on(event.name, (...args) => event.execute(...args));
	}
}

client.login(token);
You'll notice the code looks very similar to the command loading above it - read the files in the events folder and load each one individually.

The Client class in discord.js extends the EventEmitter class. Therefore, the client object exposes the .on() and .once() methods that you can use to register event listeners. These methods take two arguments: the event name and a callback function. These are defined in your separate event files as name and execute.

The callback function passed takes argument(s) returned by its respective event, collects them in an args array using the ... rest parameter syntax, then calls event.execute() while passing in the args array using the ... spread syntax. They are used here because different events in discord.js have different numbers of arguments. The rest parameter collects these variable number of arguments into a single array, and the spread syntax then takes these elements and passes them to the execute function.

After this, listening for other events is as easy as creating a new file in the events folder. The event handler will automatically retrieve and register it whenever you restart your bot.

TIP

In most cases, you can access your client instance in other files by obtaining it from one of the other discord.js structures, e.g. interaction.client in the interactionCreate event. You do not need to manually pass it to your events.




























































Cooldowns
Spam is something you generally want to avoid, especially if one of your commands require calls to other APIs or takes a bit of time to build/send.

TIP

This section assumes you followed the Command Handling part.

First, add a cooldown property to your command. This will determine how long the user would have to wait (in seconds) before using the command again.

const { SlashCommandBuilder } = require('discord.js');

module.exports = {
	cooldown: 5,
	data: new SlashCommandBuilder()
		.setName('ping')
		.setDescription('Replies with Pong!'),
	async execute(interaction) {
		// ...
	},
};
In your main file, initialize a Collection to store cooldowns of commands:

client.cooldowns = new Collection();
The key will be the command names, and the values will be Collections associating the user's id (key) to the last time (value) this user used this command. Overall the logical path to get a user's last usage of a command will be cooldowns > command > user > timestamp.

In your InteractionCreate event, add the following code:

const { cooldowns } = client;

if (!cooldowns.has(command.data.name)) {
	cooldowns.set(command.data.name, new Collection());
}

const now = Date.now();
const timestamps = cooldowns.get(command.data.name);
const defaultCooldownDuration = 3;
const cooldownAmount = (command.cooldown ?? defaultCooldownDuration) * 1000;

if (timestamps.has(interaction.user.id)) {
	// ...
}

try {
	// ...
} catch (error) {
	// ...
}
You check if the cooldowns Collection already has an entry for the command being used. If this is not the case, you can add a new entry, where the value is initialized as an empty Collection. Next, create the following variables:

now: The current timestamp.
timestamps: A reference to the Collection of user ids and timestamp key/value pairs for the triggered command.
cooldownAmount: The specified cooldown for the command, converted to milliseconds for straightforward calculation. If none is specified, this defaults to three seconds.
If the user has already used this command in this session, get the timestamp, calculate the expiration time, and inform the user of the amount of time they need to wait before using this command again. Note the use of the return statement here, causing the code below this snippet to execute only if the user has not used this command in this session or the wait has already expired.

Continuing with your current setup, this is the complete if statement:

if (timestamps.has(interaction.user.id)) {
	const expirationTime = timestamps.get(interaction.user.id) + cooldownAmount;

	if (now < expirationTime) {
		const expiredTimestamp = Math.round(expirationTime / 1000);
		return interaction.reply({ content: `Please wait, you are on a cooldown for \`${command.data.name}\`. You can use it again <t:${expiredTimestamp}:R>.`, ephemeral: true });
	}
}
Since the timestamps Collection has the user's id as the key, you can use the get() method on it to get the value and sum it up with the cooldownAmount variable to get the correct expiration timestamp and further check to see if it's expired or not.

The previous user check serves as a precaution in case the user leaves the guild. You can now use the setTimeout method, which will allow you to execute a function after a specified amount of time and remove the timeout.

if (timestamps.has(interaction.user.id)) {
	// ...
}

timestamps.set(interaction.user.id, now);
setTimeout(() => timestamps.delete(interaction.user.id), cooldownAmount);
This line causes the entry for the user under the specified command to be deleted after the command's cooldown time has expired for them.






































Reloading Commands
When writing your commands, you may find it tedious to restart your bot every time for testing the smallest changes. With a command handler, you can eliminate this issue and reload your commands while your bot is running.

WARNING

ESM does not support require and clearing import cache. You can use hot-esm to import files without cache. Windows support is experimental per this issue.

TIP

This section assumes you followed the Command Handling part.

WARNING

The reload command ideally should not be used by every user. You should deploy it as a guild command in a private guild.

const { SlashCommandBuilder } = require('discord.js');

module.exports = {
	data: new SlashCommandBuilder()
		.setName('reload')
		.setDescription('Reloads a command.')
		.addStringOption(option =>
			option.setName('command')
				.setDescription('The command to reload.')
				.setRequired(true)),
	async execute(interaction) {
		// ...
	},
};
First off, you need to check if the command you want to reload exists. You can do this check similarly to getting a command.

module.exports = {
	// ...
	async execute(interaction) {
		const commandName = interaction.options.getString('command', true).toLowerCase();
		const command = interaction.client.commands.get(commandName);

		if (!command) {
			return interaction.reply(`There is no command with name \`${commandName}\`!`);
		}
	},
};
To build the correct file path, you will need the file name. You can use command.data.name for doing that.

In theory, all there is to do is delete the previous command from client.commands and require the file again. In practice, you cannot do this easily as require() caches the file. If you were to require it again, you would load the previously cached file without any changes. You first need to delete the file from require.cache, and only then should you require and set the command file to client.commands:

delete require.cache[require.resolve(`./${command.data.name}.js`)];

try {
	interaction.client.commands.delete(command.data.name);
	const newCommand = require(`./${command.data.name}.js`);
	interaction.client.commands.set(newCommand.data.name, newCommand);
	await interaction.reply(`Command \`${newCommand.data.name}\` was reloaded!`);
} catch (error) {
	console.error(error);
	await interaction.reply(`There was an error while reloading a command \`${command.data.name}\`:\n\`${error.message}\``);
}
The snippet above uses a try...catch block to load the command file and add it to client.commands. In case of an error, it will log the full error to the console and notify the user about it with the error's message component error.message. Note that you never actually delete the command from the commands Collection and instead overwrite it. This behavior prevents you from deleting a command and ending up with no command at all after a failed require() call, as each use of the reload command checks that Collection again.







































Command response methods
There are multiple ways of responding to a slash command; each of these are covered in the following segments. Using an interaction response method confirms to Discord that your bot successfully received the interaction, and has responded to the user. Discord enforces this to ensure that all slash commands provide a good user experience (UX). Failing to respond will cause Discord to show that the command failed, even if your bot is performing other actions as a result.

The most common way of sending a response is by using the ChatInputCommandInteraction#reply() method, as you have done in earlier examples. This method acknowledges the interaction and sends a new message in response.

module.exports = {
	data: new SlashCommandBuilder()
		.setName('ping')
		.setDescription('Replies with Pong!'),
	async execute(interaction) {
		await interaction.reply('Pong!');
	},
};

User
used /ping

Guide Bot
BOT
07/29/2023
Pong!
WARNING

Initially an interaction token is only valid for three seconds, so that's the timeframe in which you are able to use the ChatInputCommandInteraction#reply() method. Responses that require more time ("Deferred Responses") are explained later in this page.

#Ephemeral responses
You may not always want everyone who has access to the channel to see a slash command's response. Previously, you would have had to DM the user to achieve this, potentially encountering the high rate limits associated with DM messages, or simply being unable to do so, if the user's DMs were disabled.

Thankfully, Discord provides a way to hide response messages from everyone but the executor of the slash command. This type of message is called an ephemeral message and can be set by providing ephemeral: true in the InteractionReplyOptions, as follows:

client.on(Events.InteractionCreate, async interaction => {
	if (!interaction.isChatInputCommand()) return;

	if (interaction.commandName === 'ping') {
		await interaction.reply({ content: 'Secret Pong!', ephemeral: true });
	}
});
Now when you run your command again, you should see something like this:


User
used /ping

Guide Bot
BOT
07/29/2023
Secret Pong!
Only you can see this
Ephemeral responses are only available for interaction responses; another great reason to use the new and improved slash command user interface.

#Editing responses
After you've sent an initial response, you may want to edit that response for various reasons. This can be achieved with the ChatInputCommandInteraction#editReply() method:

WARNING

After the initial response, an interaction token is valid for 15 minutes, so this is the timeframe in which you can edit the response and send follow-up messages. You also cannot edit the ephemeral state of a message, so ensure that your first response sets this correctly.

const wait = require('node:timers/promises').setTimeout;

client.on(Events.InteractionCreate, async interaction => {
	if (!interaction.isChatInputCommand()) return;

	if (interaction.commandName === 'ping') {
		await interaction.reply('Pong!');
		await wait(2000);
		await interaction.editReply('Pong again!');
	}
});
In fact, editing your interaction response is necessary to calculate the ping properly for this command.

#Deferred responses
As previously mentioned, Discord requires an acknowledgement from your bot within three seconds that the interaction was received. Otherwise, Discord considers the interaction to have failed and the token becomes invalid. But what if you have a command that performs a task which takes longer than three seconds before being able to reply?

In this case, you can make use of the ChatInputCommandInteraction#deferReply() method, which triggers the <application> is thinking... message. This also acts as the initial response, to confirm to Discord that the interaction was received successfully and gives you a 15-minute timeframe to complete your tasks before responding.

const wait = require('node:timers/promises').setTimeout;

client.on(Events.InteractionCreate, async interaction => {
	if (!interaction.isChatInputCommand()) return;

	if (interaction.commandName === 'ping') {
		await interaction.deferReply();
		await wait(4000);
		await interaction.editReply('Pong!');
	}
});
If you have a command that performs longer tasks, be sure to call deferReply() as early as possible.

Note that if you want your response to be ephemeral, you must pass an ephemeral flag to the InteractionDeferReplyOptions here:

await interaction.deferReply({ ephemeral: true });
It is not possible to edit a reply to change its ephemeral state once sent.

TIP

If you want to make a proper ping command, one is available in our FAQ.

#Follow-ups
The reply() and deferReply() methods are both initial responses, which tell Discord that your bot successfully received the interaction, but cannot be used to send additional messages. This is where follow-up messages come in. After having initially responded to an interaction, you can use ChatInputCommandInteraction#followUp() to send additional messages:

WARNING

After the initial response, an interaction token is valid for 15 minutes, so this is the timeframe in which you can edit the response and send follow-up messages.

client.on(Events.InteractionCreate, async interaction => {
	if (!interaction.isChatInputCommand()) return;

	if (interaction.commandName === 'ping') {
		await interaction.reply('Pong!');
		await interaction.followUp('Pong again!');
	}
});
If you run this code you should end up having something that looks like this:


User
used /ping

Guide Bot
BOT
07/29/2023
Pong!

Guide Bot
BOT
Pong!

Guide Bot
BOT
07/29/2023
Pong again!
You can also pass an ephemeral flag to the InteractionReplyOptions:

await interaction.followUp({ content: 'Pong again!', ephemeral: true });

User
used /ping

Guide Bot
BOT
07/29/2023
Pong!

Guide Bot
BOT
Pong!

Guide Bot
BOT
07/29/2023
Pong again!
Only you can see this
Note that if you use followUp() after a deferReply(), the first follow-up will edit the <application> is thinking message rather than sending a new one.

That's all, now you know everything there is to know on how to reply to slash commands!

TIP

Interaction responses can use masked links (e.g. [text](http://site.com)) in the message content.

#Fetching and deleting responses
In addition to replying to a slash command, you may also want to delete the initial reply. You can use ChatInputCommandInteraction#deleteReply() for this:

await interaction.reply('Pong!');
await interaction.deleteReply();
Lastly, you may require the Message object of a reply for various reasons, such as adding reactions. You can use the ChatInputCommandInteraction#fetchReply() method to fetch the Message instance of an initial response:

await interaction.reply('Pong!');
const message = await interaction.fetchReply();
console.log(message);
#Localized responses
In addition to the ability to provide localized command definitions, you can also localize your responses. To do this, get the locale of the user with ChatInputCommandInteraction#locale and respond accordingly:

client.on(Events.InteractionCreate, interaction => {
	const locales = {
		pl: 'Witaj Świecie!',
		de: 'Hallo Welt!',
	};
	interaction.reply(locales[interaction.locale] ?? 'Hello World (default is english)');
});





































Advanced command creation
The examples we've covered so far have all been fairly simple commands, such as ping, server, and user which all have standard static responses. However, there's much more you can do with the full suite of slash command tools!

#Adding options
Application commands can have additional options. Think of these options as arguments to a function, and as a way for the user to provide the additional information the command requires.

TIP

If you've already added options to your commands and need to know how to receive and parse them, refer to the Parsing options page in this section of the guide.

Options require at minimum a name and description. The same restrictions apply to option names as slash command names - 1-32 characters containing no capital letters, spaces, or symbols other than - and _. You can specify them as shown in the echo command below, which prompt the user to enter a String for the input option.

const { SlashCommandBuilder } = require('discord.js');

const data = new SlashCommandBuilder()
	.setName('echo')
	.setDescription('Replies with your input!')
	.addStringOption(option =>
		option.setName('input')
			.setDescription('The input to echo back'));
#Option types
By specifying the type of an ApplicationCommandOption using the corresponding method you are able to restrict what the user can provide as input, and for some options, leverage the automatic parsing of options into proper objects by Discord.

The example above uses addStringOption, the simplest form of standard text input with no additional validation. By leveraging additional option types, you could change the behavior of this command in many ways, such as using a Channel option to direct the response to a specific channel:

const { SlashCommandBuilder } = require('discord.js');

const data = new SlashCommandBuilder()
	.setName('echo')
	.setDescription('Replies with your input!')
	.addStringOption(option =>
		option.setName('input')
			.setDescription('The input to echo back'))
	.addChannelOption(option =>
		option.setName('channel')
			.setDescription('The channel to echo into'));
Or a Boolean option to give the user control over making the response ephemeral.

const { SlashCommandBuilder } = require('discord.js');

const data = new SlashCommandBuilder()
	.setName('echo')
	.setDescription('Replies with your input!')
	.addStringOption(option =>
		option.setName('input')
			.setDescription('The input to echo back'))
	.addBooleanOption(option =>
		option.setName('ephemeral')
			.setDescription('Whether or not the echo should be ephemeral'));
Listed below is a short description of the different types of options that can be added. For more information, refer to the add_____Option methods in the SlashCommandBuilder documentation.

String, Integer, Number and Boolean options all accept primitive values of their associated type.
Integer only accepts whole numbers.
Number accepts both whole numbers and decimals.
User, Channel, Role and Mentionable options will show a selection list in the Discord interface for their associated type, or will accept a Snowflake (id) as input.
Attachment options prompt the user to make an upload along with the slash command.
Subcommand and SubcommandGroup options allow you to have branching pathways of subsequent options for your commands - more on that later on this page.
TIP

Refer to the Discord API documentation for detailed explanations on the SUB_COMMAND and SUB_COMMAND_GROUP option types.

#Required options
With option types covered, you can start looking at additional forms of validation to ensure the data your bot receives is both complete and accurate. The simplest addition is making options required, to ensure the command cannot be executed without a required value. This validation can be applied to options of any type.

Review the echo example again and use setRequired(true) to mark the input option as required.

const { SlashCommandBuilder } = require('discord.js');

const data = new SlashCommandBuilder()
	.setName('echo')
	.setDescription('Replies with your input!')
	.addStringOption(option =>
		option.setName('input')
			.setDescription('The input to echo back')
			.setRequired(true));
#Choices
The String, Number, and Integer option types can have choices. If you would prefer users select from predetermined values rather than free entry, choices can help you enforce this. This is particularly useful when dealing with external datasets, APIs, and similar, where specific input formats are required.

WARNING

If you specify choices for an option, they'll be the only valid values users can pick!

Specify choices by using the addChoices() method from within the option builder, such as SlashCommandBuilder#addStringOption(). Choices require a name which is displayed to the user for selection, and a value that your bot will receive when that choice is selected, as if the user had typed it into the option manually.

The gif command example below allows users to select from predetermined categories of gifs to send:

const { SlashCommandBuilder } = require('discord.js');

const data = new SlashCommandBuilder()
	.setName('gif')
	.setDescription('Sends a random gif!')
	.addStringOption(option =>
		option.setName('category')
			.setDescription('The gif category')
			.setRequired(true)
			.addChoices(
				{ name: 'Funny', value: 'gif_funny' },
				{ name: 'Meme', value: 'gif_meme' },
				{ name: 'Movie', value: 'gif_movie' },
			));
If you have too many choices to display (the maximum is 25), you may prefer to provide dynamic choices based on what the user has typed so far. This can be achieved using autocomplete.

#Further validation
Even without predetermined choices, additional restrictions can still be applied on otherwise free inputs.

For String options, setMaxLength() and setMinLength() can enforce length limitations.
For Integer and Number options, setMaxValue() and setMinValue() can enforce range limitations on the value.
For Channel options, addChannelTypes() can restrict selection to specific channel types, e.g. ChannelType.GuildText.
We'll use these to show you how to enhance your echo command from earlier with extra validation to ensure it won't (or at least shouldn't) break when used:

const { SlashCommandBuilder, ChannelType } = require('discord.js');

const data = new SlashCommandBuilder()
	.setName('echo')
	.setDescription('Replies with your input!')
	.addStringOption(option =>
		option.setName('input')
			.setDescription('The input to echo back')
			// Ensure the text will fit in an embed description, if the user chooses that option
			.setMaxLength(2000))
	.addChannelOption(option =>
		option.setName('channel')
			.setDescription('The channel to echo into')
			// Ensure the user can only select a TextChannel for output
			.addChannelTypes(ChannelType.GuildText))
	.addBooleanOption(option =>
		option.setName('embed')
			.setDescription('Whether or not the echo should be embedded'));
#Subcommands
Subcommands are available with the .addSubcommand() method. This allows you to branch a single command to require different options depending on the subcommand chosen.

With this approach, you can merge the user and server information commands from the previous section into a single info command with two subcommands. Additionally, the user subcommand has a User type option for targeting other users, while the server subcommand has no need for this, and would just show info for the current guild.

const { SlashCommandBuilder } = require('discord.js');

const data = new SlashCommandBuilder()
	.setName('info')
	.setDescription('Get info about a user or a server!')
	.addSubcommand(subcommand =>
		subcommand
			.setName('user')
			.setDescription('Info about a user')
			.addUserOption(option => option.setName('target').setDescription('The user')))
	.addSubcommand(subcommand =>
		subcommand
			.setName('server')
			.setDescription('Info about the server'));
#Localizations
The names and descriptions of slash commands can be localized to the user's selected language. You can find the list of accepted locales on the discord API documentation.

Setting localizations with setNameLocalizations() and setDescriptionLocalizations() takes the format of an object, mapping location codes (e.g. pl and de) to their localized strings.

const { SlashCommandBuilder } = require('discord.js');

const data = new SlashCommandBuilder()
	.setName('dog')
	.setNameLocalizations({
		pl: 'pies',
		de: 'hund',
	})
	.setDescription('Get a cute picture of a dog!')
	.setDescriptionLocalizations({
		pl: 'Słodkie zdjęcie pieska!',
		de: 'Poste ein niedliches Hundebild!',
	})
	.addStringOption(option =>
		option
			.setName('breed')
			.setDescription('Breed of dog')
			.setNameLocalizations({
				pl: 'rasa',
				de: 'rasse',
			})
			.setDescriptionLocalizations({
				pl: 'Rasa psa',
				de: 'Hunderasse',
			}),
	);























































    Parsing options
#Command options
In this section, we'll cover how to access the values of a command's options. Consider the following ban command example with two options:

const { SlashCommandBuilder, PermissionFlagsBits } = require('discord.js');

module.exports = {
	data: new SlashCommandBuilder()
		.setName('ban')
		.setDescription('Select a member and ban them.')
		.addUserOption(option =>
			option
				.setName('target')
				.setDescription('The member to ban')
				.setRequired(true))
		.addStringOption(option =>
			option
				.setName('reason')
				.setDescription('The reason for banning'))
		.setDefaultMemberPermissions(PermissionFlagsBits.BanMembers)
		.setDMPermission(false),
};
In the execute method, you can retrieve the value of these two options from the CommandInteractionOptionResolver as shown below:

module.exports = {
	// data: new SlashCommandBuilder()...
	async execute(interaction) {
		const target = interaction.options.getUser('target');
		const reason = interaction.options.getString('reason') ?? 'No reason provided';

		await interaction.reply(`Banning ${target.username} for reason: ${reason}`);
		await interaction.guild.members.ban(target);
	},
};
Since reason isn't a required option, the example above uses the ?? nullish coalescing operator to set a default value in case the user does not supply a value for reason.

If the target user is still in the guild where the command is being run, you can also use .getMember('target') to get their GuildMember object.

TIP

If you want the Snowflake of a structure instead, grab the option via get() and access the Snowflake via the value property. Note that you should use const { value: name } = ... here to destructure and rename the value obtained from the CommandInteractionOption structure to avoid identifier name conflicts.

In the same way as the above examples, you can get values of any type using the corresponding CommandInteractionOptionResolver#get_____() method. String, Integer, Number and Boolean options all provide the respective primitive types, while User, Channel, Role, and Mentionable options will provide either the respective discord.js class instance if your application has a bot user in the guild or a raw API structure for commands-only deployments.

#Choices
If you specified preset choices for your String, Integer, or Number option, getting the selected choice is exactly the same as the free-entry options above. Consider the gif command example you looked at earlier:

const { SlashCommandBuilder } = require('discord.js');

module.exports = {
	data: new SlashCommandBuilder()
		.setName('gif')
		.setDescription('Sends a random gif!')
		.addStringOption(option =>
			option.setName('category')
				.setDescription('The gif category')
				.setRequired(true)
				.addChoices(
					{ name: 'Funny', value: 'gif_funny' },
					{ name: 'Meme', value: 'gif_meme' },
					{ name: 'Movie', value: 'gif_movie' },
				)),
	async execute(interaction) {
		const category = interaction.options.getString('category');
		// category must be one of 'gif_funny', 'gif_meme', or 'gif_movie'
	},
};
Notice that nothing changes - you still use getString() to get the choice value. The only difference is that in this case, you can be sure it's one of only three possible values.

#Subcommands
If you have a command that contains subcommands, the CommandInteractionOptionResolver#getSubcommand() will tell you which subcommand was used. You can then get any additional options of the selected subcommand using the same methods as above.

The snippet below uses the same info command from the subcommand creation guide to demonstrate how you can control the logic flow when replying to different subcommands:

module.exports = {
	// data: new SlashCommandBuilder()...
	async execute(interaction) {
		if (interaction.options.getSubcommand() === 'user') {
			const user = interaction.options.getUser('target');

			if (user) {
				await interaction.reply(`Username: ${user.username}\nID: ${user.id}`);
			} else {
				await interaction.reply(`Your username: ${interaction.user.username}\nYour ID: ${interaction.user.id}`);
			}
		} else if (interaction.options.getSubcommand() === 'server') {
			await interaction.reply(`Server name: ${interaction.guild.name}\nTotal members: ${interaction.guild.memberCount}`);
		}
	},
};















































Autocomplete
Autocomplete allows you to dynamically provide a selection of values to the user, based on their input, rather than relying on static choices. In this section we will cover how to add autocomplete support to your commands.

TIP

This page is a follow-up to the slash commands section covering options and option choices. Please carefully read those pages first so that you can understand the methods used in this section.

#Enabling autocomplete
To use autocomplete with your commands, instead of listing static choices, the option must be set to use autocompletion using SlashCommandStringOption#setAutocomplete():

const { SlashCommandBuilder } = require('discord.js');

const data = new SlashCommandBuilder()
	.setName('guide')
	.setDescription('Search discordjs.guide!')
	.addStringOption(option =>
		option.setName('query')
			.setDescription('Phrase to search for')
			.setAutocomplete(true));
#Responding to autocomplete interactions
To handle an AutocompleteInteraction, use the BaseInteraction#isAutocomplete() type guard to make sure the interaction instance is an autocomplete interaction. You can do this in a separate interactionCreate listener:

client.on(Events.InteractionCreate, interaction => {
	if (!interaction.isAutocomplete()) return;
	// do autocomplete handling
});
Or alternatively, by making a small change to your existing Command handler and adding an additional method to your individual command files.

The example below shows how this might be applied to a conceptual version of the guide command to determine the closest topic to the search input:

index.js
commands/guide.js
client.on(Events.InteractionCreate, async interaction => {
	if (interaction.isChatInputCommand()) {
		// command handling
	} else if (interaction.isAutocomplete()) {
		const command = interaction.client.commands.get(interaction.commandName);

		if (!command) {
			console.error(`No command matching ${interaction.commandName} was found.`);
			return;
		}

		try {
			await command.autocomplete(interaction);
		} catch (error) {
			console.error(error);
		}
	}
});
The command handling is almost identical, but notice the change from execute to autocomplete in the new else-if branch. By adding a separate autocomplete function to the module.exports of commands that require autocompletion, you can safely separate the logic of providing dynamic choices from the code that needs to respond to the slash command once it is complete.

TIP

You might have already moved this code to events/interactionCreate.js if you followed our Event handling guide too.

#Sending results
The AutocompleteInteraction class provides the AutocompleteInteraction#respond() method to send a response. Using this, you can submit an array of ApplicationCommandOptionChoiceData objects for the user to choose from. Passing an empty array will show "No options match your search" for the user.

WARNING

Unlike static choices, autocompletion suggestions are not enforced, and users may still enter free text.

The CommandInteractionOptionResolver#getFocused() method returns the currently focused option's value, which can be used to applying filtering to the choices presented. For example, to only display options starting with the focused value you can use the Array#filter() method, then using Array#map(), you can transform the array into an array of ApplicationCommandOptionChoiceData objects.

module.exports = {
	data: new SlashCommandBuilder()
		.setName('guide')
		.setDescription('Search discordjs.guide!')
		.addStringOption(option =>
			option.setName('query')
				.setDescription('Phrase to search for')
				.setAutocomplete(true)),
	async autocomplete(interaction) {
		const focusedValue = interaction.options.getFocused();
		const choices = ['Popular Topics: Threads', 'Sharding: Getting started', 'Library: Voice Connections', 'Interactions: Replying to slash commands', 'Popular Topics: Embed preview'];
		const filtered = choices.filter(choice => choice.startsWith(focusedValue));
		await interaction.respond(
			filtered.map(choice => ({ name: choice, value: choice })),
		);
	},
};
#Handling multiple autocomplete options
To distinguish between multiple options, you can pass true into CommandInteractionOptionResolver#getFocused(), which will now return the full focused object instead of just the value. This is used to get the name of the focused option below, allowing for multiple options to each have their own set of suggestions:

module.exports = {
	data: new SlashCommandBuilder()
		.setName('guide')
		.setDescription('Search discordjs.guide!')
		.addStringOption(option =>
			option.setName('query')
				.setDescription('Phrase to search for')
				.setAutocomplete(true))
		.addStringOption(option =>
			option.setName('version')
				.setDescription('Version to search in')
				.setAutocomplete(true)),
	async autocomplete(interaction) {
		const focusedOption = interaction.options.getFocused(true);
		let choices;

		if (focusedOption.name === 'query') {
			choices = ['Popular Topics: Threads', 'Sharding: Getting started', 'Library: Voice Connections', 'Interactions: Replying to slash commands', 'Popular Topics: Embed preview'];
		}

		if (focusedOption.name === 'version') {
			choices = ['v9', 'v11', 'v12', 'v13', 'v14'];
		}

		const filtered = choices.filter(choice => choice.startsWith(focusedOption.value));
		await interaction.respond(
			filtered.map(choice => ({ name: choice, value: choice })),
		);
	},
};
#Accessing other values
In addition to filtering based on the focused value, you may also wish to change the choices displayed based on the value of other arguments in the command. The following methods work the same in AutocompleteInteraction:

const string = interaction.options.getString('input');
const integer = interaction.options.getInteger('int');
const boolean = interaction.options.getBoolean('choice');
const number = interaction.options.getNumber('num');
However, the .getUser(), .getMember(), .getRole(), .getChannel(), .getMentionable() and .getAttachment() methods are not available to autocomplete interactions. Discord does not send the respective full objects for these methods until the slash command is completed. For these, you can get the Snowflake value using interaction.options.get('option').value:












































Action rows
With the components API, you can create interactive message components to enhance the functionality of your slash commands. To get started with this, the first component type you'll need to understand is the action row. To send any type of component, it must be placed in an action row.

Action rows are a fairly simple form of layout component. A message may contain up to five rows, each of which has a "width" of five units. This can be thought of as a flexible 5x5 grid. A button will consume one unit of width in a row, while a select menu will consume the whole five units of width. At this time, these are the only types of components that can be sent in a message.

WARNING

The "width units" referred to are not fixed - the actual width of each individual button will be dynamic based on its label contents.

#Building action rows
To create an action row, use the ActionRowBuilder class and the ActionRowBuilder#addComponents() method to add buttons or a select menu.

const row = new ActionRowBuilder()
	.addComponents(component);
WARNING

If you're using TypeScript, you'll need to specify the type of components your action row holds. This can be done by specifying the component builder you will add to it using a generic parameter in ActionRowBuilder.

- new ActionRowBuilder()
+ new ActionRowBuilder<ButtonBuilder>()
#Sending action rows
Once one or many components are inside your row(s), send them in the components property of your InteractionReplyOptions (extends BaseMessageOptions).

const row = new ActionRowBuilder()
	.addComponents(component);

await interaction.reply({ components: [row] });















































Buttons
The first type of interactive component we'll cover creating is a Button. Buttons are available in a variety of styles and can be used to provide permanent interfaces, temporary confirmation workflows, and other forms of additional interaction with your bot.

TIP

This page is a follow-up to the slash commands section and action rows page. Please carefully read those pages first so that you can understand the methods used here.

#Building buttons
Buttons are one of the MessageComponent classes, which can be sent via messages or interaction responses.

For this example, you're going to expand on the ban command that was previously covered on the parsing options page with a confirmation workflow.

To create your buttons, use the ButtonBuilder class, defining at least the customId, style and label.

const { ButtonBuilder, ButtonStyle, SlashCommandBuilder } = require('discord.js');

module.exports = {
	// data: new SlashCommandBuilder()...
	async execute(interaction) {
		const target = interaction.options.getUser('target');
		const reason = interaction.options.getString('reason') ?? 'No reason provided';

		const confirm = new ButtonBuilder()
			.setCustomId('confirm')
			.setLabel('Confirm Ban')
			.setStyle(ButtonStyle.Danger);

		const cancel = new ButtonBuilder()
			.setCustomId('cancel')
			.setLabel('Cancel')
			.setStyle(ButtonStyle.Secondary);
	},
};
TIP

The custom id is a developer-defined string of up to 100 characters. Use this field to ensure you can uniquely define all incoming interactions from your buttons!

#Sending buttons
To send your buttons, create an action row and add the buttons as components. Then, send the row in the components property of InteractionReplyOptions (extends BaseMessageOptions).

const { ActionRowBuilder, ButtonBuilder, ButtonStyle, SlashCommandBuilder } = require('discord.js');

module.exports = {
	// data: new SlashCommandBuilder()...
	async execute(interaction) {
		const target = interaction.options.getUser('target');
		const reason = interaction.options.getString('reason') ?? 'No reason provided';

		const confirm = new ButtonBuilder()
			.setCustomId('confirm')
			.setLabel('Confirm Ban')
			.setStyle(ButtonStyle.Danger);

		const cancel = new ButtonBuilder()
			.setCustomId('cancel')
			.setLabel('Cancel')
			.setStyle(ButtonStyle.Secondary);

		const row = new ActionRowBuilder()
			.addComponents(cancel, confirm);

		await interaction.reply({
			content: `Are you sure you want to ban ${target} for reason: ${reason}?`,
			components: [row],
		});
	},
};
Restart your bot and then send the command to a channel your bot has access to. If all goes well, you should see something like this:


User
used /ban

Guide Bot
BOT
07/29/2023
Are you sure you want to ban @User for reason: trolling?
CancelConfirm Ban
#Button styles
You'll notice in the above example that two different styles of buttons have been used, the grey Secondary style and the red Danger style. These were chosen specifically to support good UI/UX principles. In total, there are five button styles that can be used as appropriate to the action of the button:


User
used /buttons

Guide Bot
BOT
07/29/2023
PrimarySecondarySuccessDanger
Link
Primary style buttons are blue. These are suitable for most general purpose actions, where it's the primary or most significant action expected.
Secondary style buttons are grey. Use these for less important actions like the "Cancel" button in the example above.
Success style buttons are green. Similar to the Primary button, these are a good choice for "positive" confirmation actions.
Danger style buttons are red. Where the action being confirmed is "destructive", such a ban or delete, using a red button helps alert the user to the risk of the action.
Link style buttons are also grey, but are tagged with the "external link" symbol. These buttons will open the provided link in the browser without sending an interaction to the bot.
#Link buttons
Link buttons are a little different to the other styles. Link buttons must have a url, cannot have a customId and do not send an interaction event when clicked.

const button = new ButtonBuilder()
	.setLabel('discord.js docs')
	.setURL('https://discord.js.org')
	.setStyle(ButtonStyle.Link);
#Disabled buttons
If you want to prevent a button from being used, but not remove it from the message, you can disable it with the ButtonBuilder#setDisabled() method:

const button = new ButtonBuilder()
	.setCustomId('disabled')
	.setLabel('Click me?')
	.setStyle(ButtonStyle.Primary)
	.setDisabled(true);

User
used /button

Guide Bot
BOT
07/29/2023
Are you even able to
Click me?
#Emoji buttons
If you want to use a guild emoji within a ButtonBuilder, you can use the ButtonBuilder#setEmoji() method:

const button = new ButtonBuilder()
	.setCustomId('primary')
	.setLabel('Primary')
	.setStyle(ButtonStyle.Primary)
	.setEmoji('123456789012345678');









































Select menus
Select menus are one of the MessageComponent classes, which can be sent via messages or interaction responses.

TIP

This page is a follow-up to the slash commands section and action rows page. Please carefully read those pages first so that you can understand the methods used here.

#Building string select menus
The "standard" and most customizable type of select menu is the string select menu. To create a string select menu, use the StringSelectMenuBuilder and StringSelectMenuOptionBuilder classes.

If you're a Pokémon fan, you've probably made a selection pretty similar to this example at some point in your life!

const { StringSelectMenuBuilder, StringSelectMenuOptionBuilder, SlashCommandBuilder } = require('discord.js');

module.exports = {
	// data: new SlashCommandBuilder()...
	async execute(interaction) {
		const select = new StringSelectMenuBuilder()
			.setCustomId('starter')
			.setPlaceholder('Make a selection!')
			.addOptions(
				new StringSelectMenuOptionBuilder()
					.setLabel('Bulbasaur')
					.setDescription('The dual-type Grass/Poison Seed Pokémon.')
					.setValue('bulbasaur'),
				new StringSelectMenuOptionBuilder()
					.setLabel('Charmander')
					.setDescription('The Fire-type Lizard Pokémon.')
					.setValue('charmander'),
				new StringSelectMenuOptionBuilder()
					.setLabel('Squirtle')
					.setDescription('The Water-type Tiny Turtle Pokémon.')
					.setValue('squirtle'),
			);
	},
};
TIP

The custom id is a developer-defined string of up to 100 characters. Use this field to ensure you can uniquely define all incoming interactions from your select menus!

#Sending select menus
To send your select menu, create an action row and add the buttons as components. Then, send the row in the components property of InteractionReplyOptions (extends BaseMessageOptions).

const { ActionRowBuilder, StringSelectMenuBuilder, StringSelectMenuOptionBuilder, SlashCommandBuilder } = require('discord.js');

module.exports = {
	// data: new SlashCommandBuilder()...
	async execute(interaction) {
		const select = new StringSelectMenuBuilder()
			.setCustomId('starter')
			.setPlaceholder('Make a selection!')
			.addOptions(
				new StringSelectMenuOptionBuilder()
					.setLabel('Bulbasaur')
					.setDescription('The dual-type Grass/Poison Seed Pokémon.')
					.setValue('bulbasaur'),
				new StringSelectMenuOptionBuilder()
					.setLabel('Charmander')
					.setDescription('The Fire-type Lizard Pokémon.')
					.setValue('charmander'),
				new StringSelectMenuOptionBuilder()
					.setLabel('Squirtle')
					.setDescription('The Water-type Tiny Turtle Pokémon.')
					.setValue('squirtle'),
			);

		const row = new ActionRowBuilder()
			.addComponents(select);

		await interaction.reply({
			content: 'Choose your starter!',
			components: [row],
		});
	},
};
TIP

Remember that if you have more than one select menu, each one will need its own action row.

#String select menu options
String select menu options are custom-defined by the user, as shown in the example above. At a minimum, each option must have it's label and value defined. The label is shown to the user, while the value is included in the interaction sent to the bot.

In addition to these, each option can be enhanced with a description or emoji, or can be set to be selected by default.

const select = new StringSelectMenuBuilder()
	.setCustomId('select')
	.addOptions(
		new StringSelectMenuOptionBuilder()
			.setLabel('Option')
			.setValue('option')
			.setDescription('A selectable option')
			.setEmoji('123456789012345678')
			.setDefault(true),
	);
#Auto-populating select menus
Although the String select menu with it's user-defined options is the most customizable, there are four other types of select menu that auto-populate with their corresponding Discord entities, much like slash command options. These are:

UserSelectMenuBuilder
RoleSelectMenuBuilder
MentionableSelectMenuBuilder
ChannelSelectMenuBuilder
The ChannelSelectMenuBuilder can be configured to only show specific channel types using ChannelSelectMenuBuilder#setChannelTypes().

#Multi-selects
Where slash command options fall behind is in their single-select limitation on User, Role and Channel option types. Select menus can support this use case via BaseSelectMenuBuilder#setMinValues() and BaseSelectMenuBuilder#setMaxValues(). When these values are set, users can select multiple items, and the interaction will be sent with all selected values only when the user clicks outside the select menu.

module.exports = {
	// data: new SlashCommandBuilder()...
	async execute(interaction) {
		const userSelect = new UserSelectMenuBuilder()
			.setCustomId('users')
			.setPlaceholder('Select multiple users.')
			.setMinValues(1)
			.setMaxValues(10);

		const row1 = new ActionRowBuilder()
			.addComponents(userSelect);

		await interaction.reply({
			content: 'Select users:',
			components: [row1],
		});
	},
};












































Component interactions
Every button click or select menu selection on a component sent by your bot fires an interaction, triggering the Client#event:interactionCreate event. How you decide to handle this will likely depend on the purpose of the components. Options include:

Waiting for a single interaction via InteractionResponse#awaitMessageComponent().
Listening for multiple interactions over a period of time using an InteractionCollector.
Creating a permanent component handler in the Client#event:interactionCreate event.
TIP

This page is a follow-up to the slash commands section, and assumes you have created either buttons or select menus as detailed in this guide. Please carefully read those pages first so that you can understand the methods used here.

#Responding to component interactions
As with all other interactions message components interactions require a response within 3 seconds, else Discord will treat them as failed.

Like slash commands, all types of message component interactions support the reply(), deferReply(), editReply() and followUp() methods, with the option for these responses to be ephemeral. These function identically to how they do for slash commands, so refer to the page on slash command response methods for information on those.

Component interactions also support two additional methods of response, detailed below and demonstrated in examples later on the page.

#Updates
Responding to a component interaction via the update() method acknowledges the interaction by editing the message on which the component was attached. This method should be preferred to calling editReply() on the original interaction which sent the components. Like editReply(), update() cannot be used to change the ephemeral state of a message.

Once update() has been called, future messages can be sent by calling followUp() or edits can be made by calling editReply() on the component interaction.

#Deferred updates
Responding to a component interaction via the deferUpdate() method acknowledges the interaction and resets the message state. This method can be used to suppress the need for further responses, however it's encouraged to provide meaningful feedback to users via an update() or ephemeral reply() at least.

Once deferUpdate() has been called, future messages can be sent by calling followUp() or edits can be made by calling editReply() on the component interaction.

#Awaiting components
If you followed our buttons guide, the confirmation workflow for the ban command is a good example of a situation where your bot is expecting to receive a single response, from either the Confirm or Cancel button.

Begin by storing the InteractionResponse as a variable, and calling InteractionResponse#awaitMessageComponent() on this instance. This method returns a Promise that resolves when any interaction passes its filter (if one is provided), or throws if none are received before the timeout. If this happens, remove the components and notify the user.

const response = await interaction.reply({
	content: `Are you sure you want to ban ${target.username} for reason: ${reason}?`,
	components: [row],
});

const collectorFilter = i => i.user.id === interaction.user.id;

try {
	const confirmation = await response.awaitMessageComponent({ filter: collectorFilter, time: 60000 });
} catch (e) {
	await interaction.editReply({ content: 'Confirmation not received within 1 minute, cancelling', components: [] });
}
TIP

The filter applied here ensures that only the user who triggered the original interaction can use the buttons.

With the confirmation collected, check which button was clicked and perform the appropriate action.

const response = await interaction.reply({
	content: `Are you sure you want to ban ${target.username} for reason: ${reason}?`,
	components: [row],
});

const collectorFilter = i => i.user.id === interaction.user.id;
try {
	const confirmation = await response.awaitMessageComponent({ filter: collectorFilter, time: 60_000 });

	if (confirmation.customId === 'confirm') {
		await interaction.guild.members.ban(target);
		await confirmation.update({ content: `${target.username} has been banned for reason: ${reason}`, components: [] });
	} else if (confirmation.customId === 'cancel') {
		await confirmation.update({ content: 'Action cancelled', components: [] });
	}
} catch (e) {
	await interaction.editReply({ content: 'Confirmation not received within 1 minute, cancelling', components: [] });
}
#Component collectors
For situations where you want to collect multiple interactions, the Collector approach is better suited than awaiting singular interactions. Following on from the select menus guide, you're going to extend that example to use an InteractionCollector to listen for multiple StringSelectMenuInteractions.

Begin by storing the InteractionResponse as a variable, and calling InteractionResponse#createMessageComponentCollector() on this instance. This method returns an InteractionCollector that will fire its InteractionCollector#event:collect event whenever an interaction passes its filter (if one is provided).

In the collect event, each interaction is a StringSelectMenuInteraction thanks to the componentType: ComponentType.StringSelect option provided to the collector (and because that was the only type of component in the message). The selected value(s) are available via the StringSelectMenuInteraction#values property.

const response = await interaction.reply({
	content: 'Choose your starter!',
	components: [row],
});

const collector = response.createMessageComponentCollector({ componentType: ComponentType.StringSelect, time: 3_600_000 });

collector.on('collect', async i => {
	const selection = i.values[0];
	await i.reply(`${i.user} has selected ${selection}!`);
});
#The Client#interactionCreate event
Third and finally, you may wish to have a listener setup to respond to permanent button or select menu features of your guild. For this, returning to the Client#event:interactionCreate event is the best approach.

If you're event handling has been setup in multiple files as per our event handling guide, you should already have an events/interactionCreate.js file that looks something like this.

const { Events } = require('discord.js');

module.exports = {
	name: Events.InteractionCreate,
	async execute(interaction) {
		if (!interaction.isChatInputCommand()) return;

		const command = interaction.client.commands.get(interaction.commandName);

		if (!command) {
			console.error(`No command matching ${interaction.commandName} was found.`);
			return;
		}

		try {
			await command.execute(interaction);
		} catch (error) {
			console.error(`Error executing ${interaction.commandName}`);
			console.error(error);
		}
	},
};
The way this was previously set up returns from the execute function whenever it encounters an interaction that is not a ChatInputCommandInteraction, as shown on the highlighted line above. The first change that needs to be made is to invert this logic, without actually changing the functionality.

const { Events } = require('discord.js');

module.exports = {
	name: Events.InteractionCreate,
	async execute(interaction) {
		if (interaction.isChatInputCommand()) {
			const command = interaction.client.commands.get(interaction.commandName);

			if (!command) {
				console.error(`No command matching ${interaction.commandName} was found.`);
				return;
			}

			try {
				await command.execute(interaction);
			} catch (error) {
				console.error(`Error executing ${interaction.commandName}`);
				console.error(error);
			}
		}
	},
};
Now that the logic is setup to run code when something is a ChatInputCommandInteraction, rather than to stop and exit when it isn't, you can add handling for additional interaction types via simple if...else logic.

const { Events } = require('discord.js');

module.exports = {
	name: Events.InteractionCreate,
	async execute(interaction) {
		if (interaction.isChatInputCommand()) {
			const command = interaction.client.commands.get(interaction.commandName);

			if (!command) {
				console.error(`No command matching ${interaction.commandName} was found.`);
				return;
			}

			try {
				await command.execute(interaction);
			} catch (error) {
				console.error(`Error executing ${interaction.commandName}`);
				console.error(error);
			}
		} else if (interaction.isButton()) {
			// respond to the button
		} else if (interaction.isStringSelectMenu()) {
			// respond to the select menu
		}
	},
};
























Embeds
If you have been around on Discord for a bit, chances are you have seen these special messages, often sent by bots. They can have a colored border, embedded images, text fields, and other fancy properties.

In the following section, we will explain how to compose an embed, send it, and what you need to be aware of while doing so.

#Embed preview
Here is an example of how an embed may look. We will go over embed construction in the next part of this guide.


Guide Bot
BOT
07/29/2023

Some name
Some title
Some description here
Regular field title
Some value here
​
​
Inline field title
Some value here
Inline field title
Some value here
Inline field title
Some value here


Some footer text here • 01/01/2018
#Using the embed constructor
discord.js features the EmbedBuilder utility class for easy construction and manipulation of embeds.

// at the top of your file
const { EmbedBuilder } = require('discord.js');

// inside a command, event listener, etc.
const exampleEmbed = new EmbedBuilder()
	.setColor(0x0099FF)
	.setTitle('Some title')
	.setURL('https://discord.js.org/')
	.setAuthor({ name: 'Some name', iconURL: 'https://i.imgur.com/AfFp7pu.png', url: 'https://discord.js.org' })
	.setDescription('Some description here')
	.setThumbnail('https://i.imgur.com/AfFp7pu.png')
	.addFields(
		{ name: 'Regular field title', value: 'Some value here' },
		{ name: '\u200B', value: '\u200B' },
		{ name: 'Inline field title', value: 'Some value here', inline: true },
		{ name: 'Inline field title', value: 'Some value here', inline: true },
	)
	.addFields({ name: 'Inline field title', value: 'Some value here', inline: true })
	.setImage('https://i.imgur.com/AfFp7pu.png')
	.setTimestamp()
	.setFooter({ text: 'Some footer text here', iconURL: 'https://i.imgur.com/AfFp7pu.png' });

channel.send({ embeds: [exampleEmbed] });
TIP

You don't need to include all the elements showcased above. If you want a simpler embed, leave some out.

The .setColor() method accepts a ColorResolvable, e.g. an integer, HEX color string, an array of RGB values or specific color strings.

To add a blank field to the embed, you can use .addFields({ name: '\u200b', value: '\u200b' }).

The above example chains the manipulating methods to the newly created EmbedBuilder object. If you want to modify the embed based on conditions, you will need to reference it as the constant exampleEmbed (for our example).

const exampleEmbed = new EmbedBuilder().setTitle('Some title');

if (message.author.bot) {
	exampleEmbed.setColor(0x7289DA);
}
#Using an embed object
const exampleEmbed = {
	color: 0x0099ff,
	title: 'Some title',
	url: 'https://discord.js.org',
	author: {
		name: 'Some name',
		icon_url: 'https://i.imgur.com/AfFp7pu.png',
		url: 'https://discord.js.org',
	},
	description: 'Some description here',
	thumbnail: {
		url: 'https://i.imgur.com/AfFp7pu.png',
	},
	fields: [
		{
			name: 'Regular field title',
			value: 'Some value here',
		},
		{
			name: '\u200b',
			value: '\u200b',
			inline: false,
		},
		{
			name: 'Inline field title',
			value: 'Some value here',
			inline: true,
		},
		{
			name: 'Inline field title',
			value: 'Some value here',
			inline: true,
		},
		{
			name: 'Inline field title',
			value: 'Some value here',
			inline: true,
		},
	],
	image: {
		url: 'https://i.imgur.com/AfFp7pu.png',
	},
	timestamp: new Date().toISOString(),
	footer: {
		text: 'Some footer text here',
		icon_url: 'https://i.imgur.com/AfFp7pu.png',
	},
};

channel.send({ embeds: [exampleEmbed] });
TIP

You don't need to include all the elements showcased above. If you want a simpler embed, leave some out.

If you want to modify the embed object based on conditions, you will need to reference it directly (as exampleEmbed for our example). You can then (re)assign the property values as you would with any other object.

const exampleEmbed = { title: 'Some title' };

if (message.author.bot) {
	exampleEmbed.color = 0x7289da;
}
#Attaching images
You can upload images with your embedded message and use them as source for embed fields that support image URLs by constructing a AttachmentBuilder from them to send as message option alongside the embed. The attachment parameter takes a BufferResolvable or Stream including the URL to an external image.

You can then reference and use the images inside the embed itself with attachment://fileName.extension.

TIP

If you plan to attach the same image repeatedly, consider hosting it online and providing the URL in the respective embed field instead. This also makes your bot respond faster since it doesn't need to upload the image with every response depending on it.

#Using the EmbedBuilder
const { AttachmentBuilder, EmbedBuilder } = require('discord.js');
// ...
const file = new AttachmentBuilder('../assets/discordjs.png');
const exampleEmbed = new EmbedBuilder()
	.setTitle('Some title')
	.setImage('attachment://discordjs.png');

channel.send({ embeds: [exampleEmbed], files: [file] });
#Using an embed object
const { AttachmentBuilder } = require('discord.js');
// ...
const file = new AttachmentBuilder('../assets/discordjs.png');

const exampleEmbed = {
	title: 'Some title',
	image: {
		url: 'attachment://discordjs.png',
	},
};

channel.send({ embeds: [exampleEmbed], files: [file] });
WARNING

If the images don't display inside the embed but outside of it, double-check your syntax to make sure it's as shown above.

#Resending and editing
We will now explain how to edit embedded message content and resend a received embed.

#Resending a received embed
To forward a received embed you retrieve it from the messages embed array (message.embeds) and pass it to the EmbedBuilder, then it can be edited before sending it again.

WARNING

We create a new Embed from EmbedBuilder here since embeds are immutable and their values cannot be changed directly.

const receivedEmbed = message.embeds[0];
const exampleEmbed = EmbedBuilder.from(receivedEmbed).setTitle('New title');

channel.send({ embeds: [exampleEmbed] });
#Editing the embedded message content
To edit the content of an embed you need to pass a new EmbedBuilder structure or embed object to the messages .edit() method.

const exampleEmbed = new EmbedBuilder()
	.setTitle('Some title')
	.setDescription('Description after the edit');

message.edit({ embeds: [exampleEmbed] });
If you want to build the new embed data on a previously sent embed template, make sure to read the caveats in the previous section.

#Notes
To display fields side-by-side, you need at least two consecutive fields set to inline
The timestamp will automatically adjust the timezone depending on the user's device
Mentions of any kind in embeds will only render correctly within embed descriptions and field values
Mentions in embeds will not trigger a notification
Embeds allow masked links (e.g. [Guide](https://discordjs.guide/ 'optional hovertext')), but only in description and field values
#Embed limits
There are a few limits to be aware of while planning your embeds due to the API's limitations. Here is a quick reference you can come back to:

Embed titles are limited to 256 characters
Embed descriptions are limited to 4096 characters
There can be up to 25 fields
A field's name is limited to 256 characters and its value to 1024 characters
The footer text is limited to 2048 characters
The author name is limited to 256 characters
The sum of all characters from all embed structures in a message must not exceed 6000 characters
10 embeds can be sent per message












































Gateway Intents
Gateway Intents were introduced by Discord so bot developers can choose which events their bot receives based on which data it needs to function. Intents are named groups of pre-defined WebSocket events, which the discord.js client will receive. If you omit DirectMessageTyping, for example, you will no longer receive typing events from direct messages. If you do not specify intents, discord.js will throw an error.

Rather than blindly enabling all intents, consider what information you actually need. Reducing the number of unnecessary events your bot receives improves performance and reduces bandwidth and memory usage.

#Privileged Intents
Discord defines some intents as "privileged" due to the data's sensitive nature. At the time of writing this article, privileged intents are GuildPresences, MessageContent and GuildMembers. If your bot is not verified and in less than 100 guilds, you can enable privileged gateway intents in the Discord Developer Portal under "Privileged Gateway Intents" in the "Bot" section. If your bot is already verified or is about to require verification, you need to request privileged intents. You can do this in your verification application or by reaching out to Discord's support team, including why you require access to each privileged intent.

Before storming off and doing so, you should stop and carefully think about if you need these events. Discord made them opt-in so users across the platform can enjoy a higher level of privacy. Presences can expose quite a bit of personal information, including the games being played and overall online time. You might find that it isn't necessary for your bot to have this level of information about all guild members at all times, considering you still get the command author as GuildMember from the command execution message and can fetch other targets separately.

#Error: Disallowed Intents
Should you receive an error prefixed with [DisallowedIntents], please review your developer dashboard settings for all privileged intents you use. Check on the Discord API documentation for up to date information.

#Enabling Intents
To specify which events you want your bot to receive, first think about which events your bot needs to operate. Then select the required intents and add them to your client constructor, as shown below.

All gateway intents, and the events belonging to each, are listed on the Discord API documentation.

If you need your bot to receive messages (MESSAGE_CREATE - "messageCreate" in discord.js), you need the Guilds and GuildMessages intent, plus the MessageContent privileged intent to receive the content, attachments, embeds and components fields of the message.
If you want your bot to post welcome messages for new members (GUILD_MEMBER_ADD - "guildMemberAdd" in discord.js), you need the GuildMembers privileged intent, and so on.
const { Client, GatewayIntentBits } = require('discord.js');

const client = new Client({
	intents: [
		GatewayIntentBits.Guilds,
		GatewayIntentBits.GuildMessages,
		GatewayIntentBits.MessageContent,
		GatewayIntentBits.GuildMembers,
	],
});
WARNING

Note that discord.js relies heavily on caching to provide its functionality - this means an internal reliance on certain events to ensure the caches are populated and up to date.

Some methods that seem unrelated might stop working if certain events do not arrive. For example:

The Guilds intent populates and maintains the guilds, channels and guild.roles caches, plus thread-related events.
If this intent is not enabled, data for interactions and messages will include only the guild and channel id, and will not resolve to the full class.
The GuildMembers intent keeps cached guild members up to date, including changes to their roles and permissions, nickname etc.
Note that you still receive full member data with interactions and messages without this intent enabled.
Please make sure to provide the list of gateway intents and partials you use in your Client constructor when asking for support on our Discord server or GitHub repository.

#The Intents Bitfield
discord.js provides the utility structure IntentsBitField to simplify the modification of intents bitfields.

You can use the .add() and .remove() methods to add or remove flags (Intents string literals representing a certain bit) and modify the bitfield. You can provide single flags as well as an array or bitfield. To use a set of intents as a template you can pass it to the constructor. Note that the empty constructor new IntentsBitField() creates an empty Intents instance, representing no intents or the bitfield 0:

const { Client, IntentsBitField } = require('discord.js');

const myIntents = new IntentsBitField();
myIntents.add(IntentsBitField.Flags.GuildPresences, IntentsBitField.Flags.GuildMembers);

const client = new Client({ intents: myIntents });

// other examples:
const otherIntents = new IntentsBitField([IntentsBitField.Flags.Guilds, IntentsBitField.Flags.DirectMessages]);
otherIntents.remove([IntentsBitField.Flags.DirectMessages]);
If you want to view the built flags you can utilize the .toArray(), .serialize() methods. The first returns an array of flags represented in this bitfield, the second an object mapping all possible flag values to a boolean, based on their representation in this bitfield.

#More on Bitfields
Discord Intents and Permissions are stored in a 53-bit integer and calculated using bitwise operations. If you want to dive deeper into what's happening behind the curtains, check the Wikipedia and MDN articles on the topic.

In discord.js, Permissions and Intents bitfields are represented as either the decimal value of said bit field or its referenced flags. Every position in a permissions bitfield represents one of these flags and its state (either referenced 1 or not referenced 0).








































Gateway
The Gateway API lets apps open secure WebSocket connections with Discord to receive events about actions that take place in a server/guild, like when a channel is updated or a role is created. There are a few cases where apps will also use Gateway connections to update or request resources, like when updating voice state.

In most cases, performing REST operations on Discord resources can be done using the HTTP API rather than the Gateway API.
The Gateway is Discord's form of real-time communication used by clients (including apps), so there are nuances and data passed that simply isn't relevant to apps. Interacting with the Gateway can be tricky, but there are community-built libraries with built-in support that simplify the most complicated bits and pieces. If you're planning on writing a custom implementation, be sure to read the following documentation in its entirety so you understand the sacred secrets of the Gateway (or at least those that matter for apps).

Gateway Events
Gateway events are payloads sent over a Gateway connection—either from an app to Discord, or from Discord to an app. An app typically sends events when connecting and managing its connection to the Gateway, and receives events when listening to actions taking place in a server.

All Gateway events are encapsulated in a Gateway event payload.

A full list of Gateway events and their details are in the Gateway events documentation.

Example Gateway Event
{
  "op": 0,
  "d": {},
  "s": 42,
  "t": "GATEWAY_EVENT_NAME"
}
Details about Gateway event payloads are in the Gateway events documentation.

Sending Events
When sending a Gateway event (like when performing an initial handshake or updating presence), your app must send an event payload object with a valid opcode (op) and inner data object (d).

Specific rate limits are applied when sending events, which you can read about in the Rate Limiting section.
Event payloads sent over a Gateway connection:

Must be serialized in plain-text JSON or binary ETF.
Must not exceed 4096 bytes. If an event payload does exceed 4096 bytes, the connection will be closed with a 4002 close event code.
All events that your app can send via a connection are in Gateway event documentation.

Receiving Events
Receiving a Gateway event from Discord (like when a reaction is added to a message) is much more common (and slightly more complex) than sending them.

While some events are sent to your app automatically, most events require your app to define intents when Identifying. Intents are bitwise values that can be ORed (|) to indicate which events (or groups of events) you want Discord to send your app. A list of intents and their corresponding events are listed in the intents section.

When receiving events, you can also configure how events will be sent to your app, like the encoding and compression, or whether sharding should be enabled).

All events that your app can receive via a connection are in the Gateway event documentation.

Dispatch Events
Dispatch (opcode 0) events are the most common type of event your app will receive. Most Gateway events which represent actions taking place in a guild will be sent to your app as Dispatch events.

When your app is parsing a Dispatch event:

The t field can be used to determine which Gateway event the payload represents the data you can expect in the d field.
The s field represents the sequence number of the event, which is the relative order in which it occurred. You need to cache the most recent non-null s value for heartbeats, and to pass when Resuming a connection.
Connections
Gateway connections are persistent WebSockets which introduce more complexity than sending HTTP requests or responding to interactions (like Slash Commands). When interacting with the Gateway, your app must know how to open the initial connection, as well as maintain it and handle any disconnects.

Connection Lifecycle
There are nuances that aren't included in the overview below. More details about each step and event can be found in the individual sections below.
At a high-level, Gateway connections consist of the following cycle:

Flowchart with an overview of Gateway connection lifecycle

App establishes a connection with the Gateway after fetching and caching a WSS URL using the Get Gateway or Get Gateway Bot endpoint.
Discord sends the app a Hello (opcode 10) event containing a heartbeat interval in milliseconds. Read the section on Connecting
Start the Heartbeat interval. App must send a Heartbeat (opcode 1) event, then continue to send them every heartbeat interval until the connection is closed. Read the section on Sending Heartbeats
Discord will respond to each Heartbeat event with a Heartbeat ACK (opcode 11) event to confirm it was received. If an app doesn't receive a Heartbeat ACK, it should close the connection and reconnect.
Discord may send the app a Heartbeat (opcode 1) event, in which case the app should send a Heartbeat event immediately.
App sends an Identify (opcode 2) event to perform the initial handshake with the Gateway. Read the section on Identifying
Discord sends the app a Ready (opcode 0) event which indicates the handshake was successful and the connection is established. The Ready event contains a resume_gateway_url that the app should keep track of to determine the WebSocket URL an app should use to Resume. Read the section on the Ready event
The connection may be dropped for a variety of reasons. Whether the app can Resume the connection or whether it must re-identify is determined by a variety of factors like the opcode and close code that it receives. Read the section on Disconnecting
If an app can resume/reconnect, it should open a new connection using resume_gateway_url, then send a Resume (opcode 6) event. If an app cannot resume/reconnect, it should open a new connection using the cached URL from step #1, then repeat the whole Gateway cycle. Yipee! Read the section on Resuming
Connecting
Before your app can establish a connection to the Gateway, it should call the Get Gateway or the Get Gateway Bot endpoint. Either endpoint will return a payload with a url field whose value is the WSS URL you can use to open a WebSocket connection. In addition to the URL, Get Gateway Bot contains additional information about the recommended number of shards and the session start limits for your app.

When initially calling either Get Gateway or Get Gateway Bot, you should cache the value of the url field and use that when re-connecting to the Gateway.

When connecting to the URL, it's a good idea to explicitly pass the API version and encoding as query parameters. You can also optionally include whether Discord should compress data that it sends your app.

wss://gateway.discord.gg/?v=10&encoding=json is an example of a WSS URL an app may use to connect to the Gateway.
For security reasons, the Gateway cannot be accessed directly from a Cloudflare Worker. Attempts will result in a 401 Unauthorized status code.
Gateway URL Query String Params
FIELD	TYPE	DESCRIPTION	ACCEPTED VALUES
v	integer	API Version to use	API version
encoding	string	The encoding of received gateway packets	json or etf
compress?	string	The optional transport compression of gateway packets	zlib-stream
Hello Event
Once connected to the Gateway, your app will receive a Hello (opcode 10) event that contains your connection's heartbeat interval (hearbeat_interval).

The heartbeat interval indicates a length of time in milliseconds that you should use to determine how often your app needs to send a Heartbeat event in order to maintain the active connection. Heartbeating is detailed in the Sending Heartbeats section.

Example Hello Event
{
  "op": 10,
  "d": {
    "heartbeat_interval": 45000
  }
}
Sending Heartbeats
Heartbeats are pings used to let Discord know that your app is still actively using a Gateway connection. After connecting to the Gateway, your app should send heartbeats (as described below) in a background process until the Gateway connection is closed.

Heartbeat Interval
When your app opens a Gateway connection, it will receive a Hello (opcode 10) event which includes a heartbeat_interval field that has a value representing a length of time in milliseconds.

Upon receiving the Hello event, your app should wait heartbeat_interval * jitter where jitter is any random value between 0 and 1, then send its first Heartbeat (opcode 1) event. From that point until the connection is closed, your app must continually send Discord a heartbeat every heartbeat_interval milliseconds. If your app fails to send a heartbeat event in time, your connection will be closed and you will be forced to Resume.

When sending a heartbeat, your app will need to include the last sequence number your app received in the d field. The sequence number is sent to your app in the event payload in the s field. If your app hasn't received any events yet, you can just pass null in the d field.

In the first heartbeat, jitter is an offset value between 0 and heartbeat_interval that is meant to prevent too many clients (both desktop and apps) from reconnecting their sessions at the exact same time (which could cause an influx of traffic).
You can send heartbeats before the heartbeat_interval elapses, but you should avoid doing so unless necessary. There is already tolerance in the heartbeat_interval that will cover network latency, so you don't need to account for it in your implementation.

When you send a Heartbeat event, Discord will respond with a Heartbeat ACK (opcode 11) event, which is an acknowledgement that the heartbeat was received:

Example Heartbeat ACK
{
  "op": 11
}
In the event of a service outage where you stay connected to the Gateway, you should continue to send heartbeats and receive heartbeat ACKs. The Gateway will eventually respond and issue a session once it's able to.
If a client does not receive a heartbeat ACK between its attempts at sending heartbeats, this may be due to a failed or "zombied" connection. The client should immediately terminate the connection with any close code besides 1000 or 1001, then reconnect and attempt to Resume.

Heartbeat Requests
In addition to the Heartbeat interval, Discord may request additional heartbeats from your app by sending a Heartbeat (opcode 1) event. Upon receiving the event, your app should immediately send back another Heartbeat event without waiting the remainder of the current interval.

Just like with the interval, Discord will respond with an Heartbeat ACK (opcode 11) event.

Identifying
After the connection is open and your app is sending heartbeats, you should send an Identify (opcode 2) event. The Identify event is an initial handshake with the Gateway that's required before your app can begin sending or receiving most Gateway events.

Apps are limited by maximum concurrency (max_concurrency in the session start limit object) when identifying. If your app exceeds this limit, Discord will respond with a Invalid Session (opcode 9) event.

After your app sends a valid Identify payload, Discord will respond with a Ready event which indicates that your app is in a successfully-connected state with the Gateway. The Ready event is sent as a standard Dispatch (opcode 0).

Clients are limited to 1000 IDENTIFY calls to the websocket in a 24-hour period. This limit is global and across all shards, but does not include RESUME calls. Upon hitting this limit, all active sessions for the app will be terminated, the bot token will be reset, and the owner will receive an email notification. It's up to the owner to update their application with the new token.
Example Identify Payload
Below is a minimal IDENTIFY payload. IDENTIFY supports additional fields for other session properties like payload compression and an initial presence state.

See the Identify Structure for details about the event.

{
  "op": 2,
  "d": {
    "token": "my_token",
    "intents": 513,
    "properties": {
      "os": "linux",
      "browser": "my_library",
      "device": "my_library"
    }
  }
}
Ready event
As mentioned above, the Ready event is sent to your app after it sends a valid Identify payload. The Ready event includes state, like the guilds your app is in, that it needs to start interacting with the rest of the platform.

The Ready event also includes fields that you'll need to cache in order to eventually Resume your connection after disconnects. Two fields in particular are important to call out:

resume_gateway_url is a WebSocket URL that your app should use when it Resumes after a disconnect. The resume_gateway_url should be used instead of the URL used when connecting.
session_id is the ID for the Gateway session for the new connection. It's required to know which stream of events were associated with your disconnection connection.
Full details about the Ready event is in the Gateway events documentation.

Disconnecting
Gateway disconnects happen for a variety of reasons, and may be initiated by Discord or by your app.

Handling a Disconnect
Due to Discord's architecture, disconnects are a semi-regular event and should be expected and handled. When your app encounters a disconnect, it will typically be sent a close code which can be used to determine whether you can reconnect and Resume the session, or whether you have to start over and re-Identify.

After you determine whether or not your app can reconnect, you will do one of the following:

If you determine that your app can reconnect and resume the previous session, then you should reconnect using the resume_gateway_url and session_id from the Ready event. Details about when and how to resume can be found in the Resuming section.
If you cannot reconnect or the reconnect fails, you should open a new connection using the URL from the initial call to Get Gateway or Get Gateway Bot. In the case you cannot reconnect, you'll have to re-identify after opening a new connection.
A full list of the close codes can be found in the Response Codes documentation.

Initiating a Disconnect
When you close the connection to the gateway with close code 1000 or 1001, your session will be invalidated and your bot will appear offline.

If you simply close the TCP connection or use a different close code, the session will remain active and timeout after a few minutes. This can be useful when you're Resuming the previous session.

Resuming
When your app is disconnected, Discord has a process for reconnecting and resuming, which allows your app to replay any lost events starting from the last sequence number it received. After Resuming, your app will receive the missed events in the same way it would have had the connection had stayed active. Unlike the initial connection, your app does not need to re-Identify when Resuming.

There are a handful of scenarios when your app should attempt to resume:

It receives a Reconnect (opcode 7) event
It's disconnected with a close code that indicates it can reconnect. A list of close codes is in the Opcodes and Status Codes documentation.
It's disconnected but doesn't receive any close code.
It receives an Invalid Session (opcode 9) event with the d field set to true. This is an unlikely scenario, but it is possible.
Preparing to Resume
Before your app can send a Resume (opcode 6) event, it will need three values: the session_id and the resume_gateway_url from the Ready event, and the sequence number (s) from the last Dispatch (opcode 0) event it received before the disconnect.

After the connection is closed, your app should open a new connection using resume_gateway_url rather than the URL used to initially connect. If your app doesn't use the resume_gateway_url when reconnecting, it will experience disconnects at a higher rate than normal.

Once the new connection is opened, your app should send a Gateway Resume event using the session_id and sequence number mentioned above. When sending the event, session_id will have the same field name, but the last sequence number will be passed as seq in the data object (d).

When Resuming, you do not need to send an Identify event after opening the connection.

If successful, the Gateway will send the missed events in order, finishing with a Resumed event to signal event replay has finished and that all subsequent events will be new.

It's possible your app won't reconnect in time to Resume, in which case it will receive an Invalid Session (opcode 9) event. If the d field is set to false (which is most of the time), your app should disconnect. After disconnect, your app should create a new connection with your cached URL from the Get Gateway or the Get Gateway Bot endpoint, then send an Identify (opcode 2) event.

Example Gateway Resume Event
{
  "op": 6,
  "d": {
    "token": "my_token",
    "session_id": "session_id_i_stored",
    "seq": 1337
  }
}
Gateway Intents
Maintaining a stateful application can be difficult when it comes to the amount of data your app is expected to process over a Gateway connection, especially at scale. Gateway intents are a system to help you lower the computational burden.

Intents are bitwise values passed in the intents parameter when Identifying which correlate to a set of related events. For example, the event sent when a guild is created (GUILD_CREATE) and when a channel is updated (CHANNEL_UPDATE) both require the same GUILDS (1 << 0) intent (as listed in the table below). If you do not specify an intent when identifying, you will not receive any of the Gateway events associated with that intent.

Intents are optionally supported on the v6 gateway but required as of v8
Two types of intents exist:

Standard intents can be passed by default. You don't need any additional permissions or configurations.
Privileged intents require you to toggle the intent for your app in your app's settings within the Developer Portal before passing said intent. For verified apps (required for apps in 100+ guilds), the intent must also be approved after the verification process to use the intent. More information about privileged intents can be found in the section below.
The connection with your app will be closed if it passes invalid intents (4013 close code), or a privileged intent that hasn't been configured or approved for your app (4014 close code).

List of Intents
Below is a list of all intents and the Gateway events associated with them. Any events not listed means it's not associated with an intent and will always be sent to your app.

All events, including those that aren't associated with an intent, are in the Gateway events documentation.

GUILDS (1 << 0)
  - GUILD_CREATE
  - GUILD_UPDATE
  - GUILD_DELETE
  - GUILD_ROLE_CREATE
  - GUILD_ROLE_UPDATE
  - GUILD_ROLE_DELETE
  - CHANNEL_CREATE
  - CHANNEL_UPDATE
  - CHANNEL_DELETE
  - CHANNEL_PINS_UPDATE
  - THREAD_CREATE
  - THREAD_UPDATE
  - THREAD_DELETE
  - THREAD_LIST_SYNC
  - THREAD_MEMBER_UPDATE
  - THREAD_MEMBERS_UPDATE *
  - STAGE_INSTANCE_CREATE
  - STAGE_INSTANCE_UPDATE
  - STAGE_INSTANCE_DELETE

GUILD_MEMBERS (1 << 1) **
  - GUILD_MEMBER_ADD
  - GUILD_MEMBER_UPDATE
  - GUILD_MEMBER_REMOVE
  - THREAD_MEMBERS_UPDATE *

GUILD_MODERATION (1 << 2)
  - GUILD_AUDIT_LOG_ENTRY_CREATE
  - GUILD_BAN_ADD
  - GUILD_BAN_REMOVE

GUILD_EMOJIS_AND_STICKERS (1 << 3)
  - GUILD_EMOJIS_UPDATE
  - GUILD_STICKERS_UPDATE

GUILD_INTEGRATIONS (1 << 4)
  - GUILD_INTEGRATIONS_UPDATE
  - INTEGRATION_CREATE
  - INTEGRATION_UPDATE
  - INTEGRATION_DELETE

GUILD_WEBHOOKS (1 << 5)
  - WEBHOOKS_UPDATE

GUILD_INVITES (1 << 6)
  - INVITE_CREATE
  - INVITE_DELETE

GUILD_VOICE_STATES (1 << 7)
  - VOICE_STATE_UPDATE

GUILD_PRESENCES (1 << 8) **
  - PRESENCE_UPDATE

GUILD_MESSAGES (1 << 9)
  - MESSAGE_CREATE
  - MESSAGE_UPDATE
  - MESSAGE_DELETE
  - MESSAGE_DELETE_BULK

GUILD_MESSAGE_REACTIONS (1 << 10)
  - MESSAGE_REACTION_ADD
  - MESSAGE_REACTION_REMOVE
  - MESSAGE_REACTION_REMOVE_ALL
  - MESSAGE_REACTION_REMOVE_EMOJI

GUILD_MESSAGE_TYPING (1 << 11)
  - TYPING_START

DIRECT_MESSAGES (1 << 12)
  - MESSAGE_CREATE
  - MESSAGE_UPDATE
  - MESSAGE_DELETE
  - CHANNEL_PINS_UPDATE

DIRECT_MESSAGE_REACTIONS (1 << 13)
  - MESSAGE_REACTION_ADD
  - MESSAGE_REACTION_REMOVE
  - MESSAGE_REACTION_REMOVE_ALL
  - MESSAGE_REACTION_REMOVE_EMOJI

DIRECT_MESSAGE_TYPING (1 << 14)
  - TYPING_START

MESSAGE_CONTENT (1 << 15) ***

GUILD_SCHEDULED_EVENTS (1 << 16)
  - GUILD_SCHEDULED_EVENT_CREATE
  - GUILD_SCHEDULED_EVENT_UPDATE
  - GUILD_SCHEDULED_EVENT_DELETE
  - GUILD_SCHEDULED_EVENT_USER_ADD
  - GUILD_SCHEDULED_EVENT_USER_REMOVE

AUTO_MODERATION_CONFIGURATION (1 << 20)
  - AUTO_MODERATION_RULE_CREATE
  - AUTO_MODERATION_RULE_UPDATE
  - AUTO_MODERATION_RULE_DELETE

AUTO_MODERATION_EXECUTION (1 << 21)
  - AUTO_MODERATION_ACTION_EXECUTION
* Thread Members Update contains different data depending on which intents are used.

** Events under the GUILD_PRESENCES and GUILD_MEMBERS intents are turned off by default on all API versions. If you are using API v6, you will receive those events if you are authorized to receive them and have enabled the intents in the Developer Portal. You do not need to use intents on API v6 to receive these events; you just need to enable the flags. If you are using API v8 or above, intents are mandatory and must be specified when identifying.

*** MESSAGE_CONTENT does not represent individual events, but rather affects what data is present for events that could contain message content fields. More information is in the message content intent section.

Caveats
Guild Member Update is sent for current-user updates regardless of whether the GUILD_MEMBERS intent is set.

Guild Create and Request Guild Members are uniquely affected by intents. See these sections for more information.

Thread Members Update by default only includes if the current user was added to or removed from a thread. To receive these updates for other users, request the GUILD_MEMBERS Gateway Intent.

Privileged Intents
Some intents are defined as "privileged" due to the sensitive nature of the data. Currently, those intents include:

GUILD_PRESENCES
GUILD_MEMBERS
MESSAGE_CONTENT
Apps that qualify for verification must be approved for the privileged intent(s) before they can use them. After your app is verified, you can request privileged intents within the app's settings within the Developer Portal.

Before you specify privileged intents in your IDENTIFY payload, you must enable the privileged intents your app requires. Verified apps can only use privileged intents after they've been approved for them.

Unverified apps can use privileged intents without approval, but still must enable them in their app's settings. If the app's verification status changes, it will then have to apply for the privileged intent(s).
In addition to the gateway restrictions described here, Discord's REST API is also affected by Privileged Intents. For example, to use the List Guild Members endpoint, you must have the GUILD_MEMBERS intent enabled for your application. This behavior is independent of whether the intent is set during IDENTIFY.

Enabling Privileged Intents
Before using privileged intents, you must enable them in your app's settings. In the Developer Portal, you can navigate to your app's settings then toggle the privileged intents on the Bots page under the "Privileged Gateway Intents" section. You should only toggle privileged intents that your bot requires to function.

If your app qualifies for verification, you must first verify your app and request access to these intents during the verification process. If your app is already verified and you need to request additional privileged intents, you can contact support.

Gateway Restrictions
Privileged intents affect which Gateway events your app is permitted to receive. When using API v8 and above, all intents (privileged and not) must be specified in the intents parameter when Identifying. If you pass a privileged intent in the intents parameter without configuring it in your app's settings, or being approved for it during verification, your Gateway connection will be closed with a (4014 close code).

For API v6, you will receive events associated with the privileged intents your app has configured and is authorized to receive without passing those intents into the intents parameter when Identifying.
Events associated with the GUILD_PRESENCES and GUILD_MEMBERS intents are turned off by default regardless of the API version.

HTTP Restrictions
In addition to Gateway restrictions, privileged intents also affect the HTTP API endpoints your app is permitted to call, and the data it can receive. For example, to use the List Guild Members endpoint, your app must enable the GUILD_MEMBERS intent (and be approved for it if eligible for verification).

HTTP API restrictions are independent of Gateway restrictions, and are unaffected by which intents your app passes in the intents parameter when Identifying.

Message Content Intent
MESSAGE_CONTENT (1 << 15) is a unique privileged intent that isn't directly associated with any Gateway events. Instead, access to MESSAGE_CONTENT permits your app to receive message content data across the APIs.

Any fields affected by the message content intent are noted in the relevant documentation. For example, the content, embeds, attachments, and components fields in message objects all contain message content and therefore require the intent.

Like other privileged intents, MESSAGE_CONTENT must be approved for your app. After your app is verified, you can apply for the intent from your app's settings within the Developer Portal. You can read more about the message content intent review policy in the Help Center.
Apps without the intent will receive empty values in fields that contain user-inputted content with a few exceptions:

Content in messages that an app sends
Content in DMs with the app
Content in which the app is mentioned
Content of the message a message context menu command is used on
Rate Limiting
This section refers to Gateway rate limits, not HTTP API rate limits
Apps can send 120 gateway events per connection every 60 seconds, meaning an average of 2 commands per second. Apps that surpass the limit are immediately disconnected from the Gateway. Similar to other rate limits, repeat offenders will have their API access revoked.

Apps also have a limit for concurrent Identify requests allowed per 5 seconds. If you hit this limit, the Gateway will respond with an Invalid Session (opcode 9).

Encoding and Compression
When establishing a connection to the Gateway, apps can use the encoding parameter to choose whether to communicate with Discord using a plain-text JSON or binary ETF encoding. You can pick whichever encoding type you're more comfortable with, but both have their own quirks. If you aren't sure which encoding to use, JSON is generally recommended.

Apps can also optionally enable compression to receive zlib-compressed packets. Payload compression can only be enabled when using a JSON encoding, but transport compression can be used regardless of encoding type.

Using JSON Encoding
When using the plain-text JSON encoding, apps have the option to enable payload compression.

Payload Compression
If an app is using payload compression, it cannot use transport compression.
Payload compression enables optional per-packet compression for some events when Discord is sending events over the connection.

Payload compression uses the zlib format (see RFC1950 2.2) when sending payloads. To enable payload compression, your app can set compress to true when sending an Identify (opcode 2) event. Note that even when payload compression is enabled, not all payloads will be compressed.

When payload compression is enabled, your app (or library) must detect and decompress these payloads to plain-text JSON before attempting to parse them. If you are using payload compression, the gateway does not implement a shared compression context between events sent.

Payload compression will be disabled if you use transport compression.

Using ETF Encoding
When using ETF (External Term Format) encoding, there are some specific behaviors you should know:

Snowflake IDs are transmitted as 64-bit integers or strings.
Your app can't send compressed messages to the server.
When sending payloads, you must use string keys. Using atom keys will result in a 4002 decode error.
See erlpack for an ETF implementation example.

Transport Compression
Transport compression enables optional compression for all packets when Discord is sending events over the connection. The only currently-available transport compression option is zlib-stream.

When transport compression is enabled, your app needs to process received data through a single Gateway connection using a shared zlib context. However, each Gateway connection should use its own unique zlib context.

When processing transport-compressed data, you should push received data to a buffer until you receive the 4-byte Z_SYNC_FLUSH suffix (00 00 ff ff). After you receive the Z_SYNC_FLUSH suffix, you can then decompress the buffer.

Transport Compression Example
# Z_SYNC_FLUSH suffix
ZLIB_SUFFIX = b'\x00\x00\xff\xff'
# initialize a buffer to store chunks
buffer = bytearray()
# create a shared zlib inflation context to run chunks through
inflator = zlib.decompressobj()

# ...
def on_websocket_message(msg):
  # always push the message data to your cache
  buffer.extend(msg)

  # check if the last four bytes are equal to ZLIB_SUFFIX
  if len(msg) < 4 or msg[-4:] != ZLIB_SUFFIX:
    return

  # if the message *does* end with ZLIB_SUFFIX,
  # get the full message by decompressing the buffers
  # NOTE: the message is utf-8 encoded.
  msg = inflator.decompress(buffer)
  buffer = bytearray()

  # here you can treat `msg` as either JSON or ETF encoded,
  # depending on your `encoding` param
Tracking State
Most of a client's state is provided during the initial Ready event and in the Guild Create events that follow.

As resources continue to be created, updated, and deleted, Gateway events are sent to notify the app of these changes and to provide associated data. To avoid excessive API calls, apps should cache as many relevant resource states as possible, and update them as new events are received.

For larger apps, client state can grow to be very large. Therefore, we recommend only storing data in memory that are needed for the app to operate. In some cases, there isn't a need to cache member information (like roles or permissions) since some events like MESSAGE_CREATE have the full member object included.
An example of state tracking can be considered in the case of an app that wants to track member status: when initially connecting to the Gateway, the app will receive information about the online status of guild members (whether they're online, idle, dnd, or offline). To keep the state updated, the app will track and parse Presence Update events as they're received, then update the cached member objects accordingly.

Guild Availability
When connecting to the gateway as a bot user, guilds that the bot is a part of will start out as unavailable. Don't fret! The gateway will automatically attempt to reconnect on your behalf. As guilds become available to you, you will receive Guild Create events.

Sharding
As apps grow and are added to an increasing number of guilds, some developers may find it necessary to divide portions of their app's operations across multiple processes. As such, the Gateway implements a method of user-controlled guild sharding which allows apps to split events across a number of Gateway connections. Guild sharding is entirely controlled by an app, and requires no state-sharing between separate connections to operate. While all apps can enable sharding, it's not necessary for apps in a smaller number of guilds.

Each shard can only support a maximum of 2500 guilds, and apps that are in 2500+ guilds must enable sharding.
To enable sharding on a connection, the app should send the shard array in the Identify payload. The first item in this array should be the zero-based integer value of the current shard, while the second represents the total number of shards. DMs will only be sent to shard 0.

The Get Gateway Bot endpoint provides a recommended number of shards for your app in the shards field
To calculate which events will be sent to which shard, the following formula can be used:

Sharding Formula
shard_id = (guild_id >> 22) % num_shards
As an example, if you wanted to split the connection between three shards, you'd use the following values for shard for each connection: [0, 3], [1, 3], and [2, 3]. Note that only the first shard ([0, 3]) would receive DMs.

Note that num_shards does not relate to (or limit) the total number of potential sessions. It is only used for routing traffic. As such, sessions do not have to be identified in an evenly-distributed manner when sharding. You can establish multiple sessions with the same [shard_id, num_shards], or sessions with different num_shards values. This allows you to create sessions that will handle more or less traffic for more fine-tuned load balancing, or to orchestrate "zero-downtime" scaling/updating by handing off traffic to a new deployment of sessions with a higher or lower num_shards count that are prepared in parallel.

Max Concurrency
If you have multiple shards, you may start them concurrently based on the max_concurrency value returned to you on session start. Which shards you can start concurrently are assigned based on a key for each shard. The rate limit key for a given shard can be computed with

rate_limit_key = shard_id % max_concurrency
This puts your shards into "buckets" of max_concurrency size. When you start your bot, you may start up to max_concurrency shards at a time, and you must start them by "bucket" in order. To explain another way, let's say you have 16 shards, and your max_concurrency is 16:

shard_id: 0, rate limit key (0 % 16): 0
shard_id: 1, rate limit key (1 % 16): 1
shard_id: 2, rate limit key (2 % 16): 2
shard_id: 3, rate limit key (3 % 16): 3
shard_id: 4, rate limit key (4 % 16): 4
shard_id: 5, rate limit key (5 % 16): 5
shard_id: 6, rate limit key (6 % 16): 6
shard_id: 7, rate limit key (7 % 16): 7
shard_id: 8, rate limit key (8 % 16): 8
shard_id: 9, rate limit key (9 % 16): 9
shard_id: 10, rate limit key (10 % 16): 10
shard_id: 11, rate limit key (11 % 16): 11
shard_id: 12, rate limit key (12 % 16): 12
shard_id: 13, rate limit key (13 % 16): 13
shard_id: 14, rate limit key (14 % 16): 14
shard_id: 15, rate limit key (15 % 16): 15
You may start all 16 of your shards at once, because each has a rate_limit_key which fills the bucket of 16 shards. However, let's say you had 32 shards:

shard_id: 0, rate limit key (0 % 16): 0
shard_id: 1, rate limit key (1 % 16): 1
shard_id: 2, rate limit key (2 % 16): 2
shard_id: 3, rate limit key (3 % 16): 3
shard_id: 4, rate limit key (4 % 16): 4
shard_id: 5, rate limit key (5 % 16): 5
shard_id: 6, rate limit key (6 % 16): 6
shard_id: 7, rate limit key (7 % 16): 7
shard_id: 8, rate limit key (8 % 16): 8
shard_id: 9, rate limit key (9 % 16): 9
shard_id: 10, rate limit key (10 % 16): 10
shard_id: 11, rate limit key (11 % 16): 11
shard_id: 12, rate limit key (12 % 16): 12
shard_id: 13, rate limit key (13 % 16): 13
shard_id: 14, rate limit key (14 % 16): 14
shard_id: 15, rate limit key (15 % 16): 15
shard_id: 16, rate limit key (16 % 16): 0
shard_id: 17, rate limit key (17 % 16): 1
shard_id: 18, rate limit key (18 % 16): 2
shard_id: 19, rate limit key (19 % 16): 3
shard_id: 20, rate limit key (20 % 16): 4
shard_id: 21, rate limit key (21 % 16): 5
shard_id: 22, rate limit key (22 % 16): 6
shard_id: 23, rate limit key (23 % 16): 7
shard_id: 24, rate limit key (24 % 16): 8
shard_id: 25, rate limit key (25 % 16): 9
shard_id: 26, rate limit key (26 % 16): 10
shard_id: 27, rate limit key (27 % 16): 11
shard_id: 28, rate limit key (28 % 16): 12
shard_id: 29, rate limit key (29 % 16): 13
shard_id: 30, rate limit key (30 % 16): 14
shard_id: 31, rate limit key (31 % 16): 15
In this case, you must start the shard buckets in "order". That means that you can start shard 0 -> shard 15 concurrently, and then you can start shard 16 -> shard 31.

Sharding for Large Bots
If your bot is in more than 150,000 guilds, there are some additional considerations you must take around sharding. Discord will migrate your bot to large bot sharding when it starts to get near the large bot sharding threshold. The bot owner(s) will receive a system DM and email confirming this move has completed as well as what shard number has been assigned.

The number of shards you run must be a multiple of the shard number provided when reaching out to you. If you attempt to start your bot with an invalid number of shards, your Gateway connection will close with a 4010 Invalid Shard close code.

The Get Gateway Bot endpoint will always return the correct amount of shards, so if you're already using this endpoint to determine your number of shards, you shouldn't require any changes.

The session start limit for these bots will also be increased from 1000 to max(2000, (guild_count / 1000) * 3) per day. You also receive an increased max_concurrency, the number of shards you can concurrently start.

Get Gateway
GET/gateway
This endpoint does not require authentication.
Returns an object with a valid WSS URL which the app can use when Connecting to the Gateway. Apps should cache this value and only call this endpoint to retrieve a new URL when they are unable to properly establish a connection using the cached one.

Example Response
{
  "url": "wss://gateway.discord.gg/"
}
Get Gateway Bot
GET/gateway/bot
This endpoint requires authentication using a valid bot token.
Returns an object based on the information in Get Gateway, plus additional metadata that can help during the operation of large or sharded bots. Unlike the Get Gateway, this route should not be cached for extended periods of time as the value is not guaranteed to be the same per-call, and changes as the bot joins/leaves guilds.

JSON Response
FIELD	TYPE	DESCRIPTION
url	string	WSS URL that can be used for connecting to the Gateway
shards	integer	Recommended number of shards to use when connecting
session_start_limit	session_start_limit object	Information on the current session start limit
Example Response
{
  "url": "wss://gateway.discord.gg/",
  "shards": 9,
  "session_start_limit": {
    "total": 1000,
    "remaining": 999,
    "reset_after": 14400000,
    "max_concurrency": 1
  }
}
Session Start Limit Object
Session Start Limit Structure
FIELD	TYPE	DESCRIPTION
total	integer	Total number of session starts the current user is allowed
remaining	integer	Remaining number of session starts the current user is allowed
reset_after	integer	Number of milliseconds after which the limit resets
max_concurrency	integer	Number of identify requests allowed per 5 seconds